<!DOCTYPE html>
<head>
  <title>
    Designable Playground
  </title>
</head>
<body>
  <div id="root">
  </div>
  
  
  <!-- <script src="https://unpkg.com/@formily/reactive/dist/formily.reactive.umd.production.js"></script> -->
 
  <script id="path-script">
    (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('formily.path', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Formily = global.Formily || {}, global.Formily.Path = {})));
})(this, (function (exports) { 'use strict';

    (function() {
        const env = {"NODE_ENV":"development"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    var ContextType = function (flag, props) {
        return __assign({ flag: flag }, props);
    };
    var bracketContext = ContextType('[]');
    var bracketArrayContext = ContextType('[\\d]');
    var bracketDContext = ContextType('[[]]');
    var parenContext = ContextType('()');
    var braceContext = ContextType('{}');
    var destructorContext = ContextType('{x}');

    var TokenType = function (flag, props) {
        return __assign({ flag: flag }, props);
    };
    var nameTok = TokenType('name', {
        expectNext: function (next) {
            if (this.includesContext(destructorContext)) {
                return (next === nameTok ||
                    next === commaTok ||
                    next === bracketRTok ||
                    next === braceRTok ||
                    next === colonTok);
            }
            return (next === dotTok ||
                next === commaTok ||
                next === eofTok ||
                next === bracketRTok ||
                next === parenRTok ||
                next === colonTok ||
                next === expandTok ||
                next === bracketLTok);
        },
    });
    var starTok = TokenType('*', {
        expectNext: function (next) {
            return (next === dotTok ||
                next === parenLTok ||
                next === bracketLTok ||
                next === eofTok ||
                next === commaTok ||
                next === parenRTok);
        },
    });
    var dbStarTok = TokenType('**', {
        expectNext: function (next) {
            return (next === dotTok ||
                next === bracketLTok ||
                next === eofTok ||
                next === commaTok ||
                next === parenRTok);
        },
    });
    var dotTok = TokenType('.', {
        expectNext: function (next) {
            return (next === dotTok ||
                next === nameTok ||
                next === bracketDLTok ||
                next === starTok ||
                next === dbStarTok ||
                next === bracketLTok ||
                next === braceLTok ||
                next === eofTok);
        },
        expectPrev: function (prev) {
            return (prev === dotTok ||
                prev === nameTok ||
                prev === bracketDRTok ||
                prev === starTok ||
                prev === parenRTok ||
                prev === bracketRTok ||
                prev === expandTok ||
                prev === braceRTok);
        },
    });
    var bangTok = TokenType('!', {
        expectNext: function (next) {
            return next === nameTok || next === bracketDLTok;
        },
    });
    var colonTok = TokenType(':', {
        expectNext: function (next) {
            if (this.includesContext(destructorContext)) {
                return next === nameTok || next === braceLTok || next === bracketLTok;
            }
            return next === nameTok || next === bracketDLTok || next === bracketRTok;
        },
    });
    var braceLTok = TokenType('{', {
        expectNext: function (next) {
            return next === nameTok;
        },
        expectPrev: function (prev) {
            if (this.includesContext(destructorContext)) {
                return prev === colonTok || prev === commaTok || prev === bracketLTok;
            }
            return prev === dotTok || prev === colonTok || prev === parenLTok;
        },
        updateContext: function () {
            this.state.context.push(braceContext);
        },
    });
    var braceRTok = TokenType('}', {
        expectNext: function (next) {
            if (this.includesContext(destructorContext)) {
                return (next === commaTok ||
                    next === braceRTok ||
                    next === eofTok ||
                    next === bracketRTok);
            }
            return next === dotTok || next === eofTok || next === commaTok;
        },
        expectPrev: function (prev) {
            return prev === nameTok || prev === braceRTok || prev === bracketRTok;
        },
        updateContext: function () {
            this.state.context.pop(braceContext);
        },
    });
    var bracketLTok = TokenType('[', {
        expectNext: function (next) {
            if (this.includesContext(destructorContext)) {
                return (next === nameTok ||
                    next === bracketLTok ||
                    next === braceLTok ||
                    next === bracketRTok);
            }
            return (next === nameTok ||
                next === bracketDLTok ||
                next === colonTok ||
                next === bracketLTok ||
                next === ignoreTok ||
                next === bracketRTok);
        },
        expectPrev: function (prev) {
            if (this.includesContext(destructorContext)) {
                return prev === colonTok || prev === commaTok || prev === bracketLTok;
            }
            return (prev === starTok ||
                prev === bracketLTok ||
                prev === dotTok ||
                prev === nameTok ||
                prev === parenLTok ||
                prev == commaTok);
        },
        updateContext: function () {
            this.state.context.push(bracketContext);
        },
    });
    var bracketRTok = TokenType(']', {
        expectNext: function (next) {
            if (this.includesContext(destructorContext)) {
                return (next === commaTok ||
                    next === braceRTok ||
                    next === bracketRTok ||
                    next === eofTok);
            }
            return (next === dotTok ||
                next === eofTok ||
                next === commaTok ||
                next === parenRTok ||
                next === bracketRTok);
        },
        updateContext: function () {
            if (this.includesContext(bracketArrayContext))
                return;
            if (!this.includesContext(bracketContext))
                throw this.unexpect();
            this.state.context.pop();
        },
    });
    var bracketDLTok = TokenType('[[', {
        updateContext: function () {
            this.state.context.push(bracketDContext);
        },
    });
    var bracketDRTok = TokenType(']]', {
        updateContext: function () {
            if (this.curContext() !== bracketDContext)
                throw this.unexpect();
            this.state.context.pop();
        },
    });
    var parenLTok = TokenType('(', {
        expectNext: function (next) {
            return (next === nameTok ||
                next === bracketDLTok ||
                next === braceLTok ||
                next === bangTok ||
                next === bracketLTok);
        },
        expectPrev: function (prev) {
            return prev === starTok;
        },
        updateContext: function () {
            this.state.context.push(parenContext);
        },
    });
    var parenRTok = TokenType(')', {
        expectNext: function (next) {
            return (next === dotTok ||
                next === eofTok ||
                next === commaTok ||
                next === parenRTok);
        },
        updateContext: function () {
            if (this.curContext() !== parenContext)
                throw this.unexpect();
            this.state.context.pop();
        },
    });
    var commaTok = TokenType(',', {
        expectNext: function (next) {
            return (next === nameTok ||
                next === bracketDLTok ||
                next === bracketLTok ||
                next === braceLTok);
        },
    });
    var ignoreTok = TokenType('ignore', {
        expectNext: function (next) {
            return next === bracketDRTok;
        },
        expectPrev: function (prev) {
            return prev == bracketDLTok;
        },
    });
    var expandTok = TokenType('expandTok', {
        expectNext: function (next) {
            return (next === dotTok ||
                next === eofTok ||
                next === commaTok ||
                next === parenRTok);
        },
    });
    var eofTok = TokenType('eof');

    var nonASCIIWhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
    var fullCharCodeAtPos = function (input, pos) {
        if (String.fromCharCode)
            return input.codePointAt(pos);
        var code = input.charCodeAt(pos);
        if (code <= 0xd7ff || code >= 0xe000)
            return code;
        var next = input.charCodeAt(pos + 1);
        return (code << 10) + next - 0x35fdc00;
    };
    var isRewordCode = function (code) {
        return code === 42 ||
            code === 46 ||
            code === 33 ||
            code === 91 ||
            code === 93 ||
            code === 40 ||
            code === 41 ||
            code === 44 ||
            code === 58 ||
            code === 126 ||
            code === 123 ||
            code === 125;
    };
    var getError = function (message, props) {
        var err = new Error(message);
        Object.assign(err, props);
        return err;
    };
    var slice = function (string, start, end) {
        var str = '';
        for (var i = start; i < end; i++) {
            var ch = string.charAt(i);
            if (ch !== '\\') {
                str += ch;
            }
        }
        return str;
    };
    var Tokenizer = /** @class */ (function () {
        function Tokenizer(input) {
            this.input = input;
            this.state = {
                context: [],
                type: null,
                pos: 0,
            };
            this.type_ = null;
        }
        Tokenizer.prototype.curContext = function () {
            return this.state.context[this.state.context.length - 1];
        };
        Tokenizer.prototype.includesContext = function (context) {
            for (var len = this.state.context.length - 1; len >= 0; len--) {
                if (this.state.context[len] === context) {
                    return true;
                }
            }
            return false;
        };
        Tokenizer.prototype.unexpect = function (type) {
            type = type || this.state.type;
            return getError("Unexpect token \"".concat(type.flag, "\" in ").concat(this.state.pos, " char."), {
                pos: this.state.pos,
            });
        };
        Tokenizer.prototype.expectNext = function (type, next) {
            if (type && type.expectNext) {
                if (next && !type.expectNext.call(this, next)) {
                    throw getError("Unexpect token \"".concat(next.flag, "\" token should not be behind \"").concat(type.flag, "\" token.(").concat(this.state.pos, "th char)"), {
                        pos: this.state.pos,
                    });
                }
            }
        };
        Tokenizer.prototype.expectPrev = function (type, prev) {
            if (type && type.expectPrev) {
                if (prev && !type.expectPrev.call(this, prev)) {
                    throw getError("Unexpect token \"".concat(type.flag, "\" should not be behind \"").concat(prev.flag, "\"(").concat(this.state.pos, "th char)."), {
                        pos: this.state.pos,
                    });
                }
            }
        };
        Tokenizer.prototype.match = function (type) {
            return this.state.type === type;
        };
        Tokenizer.prototype.skipSpace = function () {
            if (this.curContext() === bracketDContext)
                return;
            loop: while (this.state.pos < this.input.length) {
                var ch = this.input.charCodeAt(this.state.pos);
                switch (ch) {
                    case 32:
                    case 160:
                        ++this.state.pos;
                        break;
                    case 13:
                        if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                            ++this.state.pos;
                        }
                    case 10:
                    case 8232:
                    case 8233:
                        ++this.state.pos;
                        break;
                    default:
                        if ((ch > 8 && ch < 14) ||
                            (ch >= 5760 && nonASCIIWhitespace.test(String.fromCharCode(ch)))) {
                            ++this.state.pos;
                        }
                        else {
                            break loop;
                        }
                }
            }
        };
        Tokenizer.prototype.next = function () {
            this.type_ = this.state.type;
            if (this.input.length <= this.state.pos) {
                return this.finishToken(eofTok);
            }
            this.skipSpace();
            this.readToken(this.getCode(), this.state.pos > 0 ? this.getCode(this.state.pos - 1) : -Infinity);
        };
        Tokenizer.prototype.getCode = function (pos) {
            if (pos === void 0) { pos = this.state.pos; }
            return fullCharCodeAtPos(this.input, pos);
        };
        Tokenizer.prototype.eat = function (type) {
            if (this.match(type)) {
                this.next();
                return true;
            }
            else {
                return false;
            }
        };
        Tokenizer.prototype.readKeyWord = function () {
            var startPos = this.state.pos, string = '';
            while (true) {
                var code = this.getCode();
                var prevCode = this.getCode(this.state.pos - 1);
                if (this.input.length === this.state.pos) {
                    string = slice(this.input, startPos, this.state.pos + 1);
                    break;
                }
                if (!isRewordCode(code) || prevCode === 92) {
                    if (code === 32 ||
                        code === 160 ||
                        code === 10 ||
                        code === 8232 ||
                        code === 8233) {
                        string = slice(this.input, startPos, this.state.pos);
                        break;
                    }
                    if (code === 13 && this.input.charCodeAt(this.state.pos + 1) === 10) {
                        string = slice(this.input, startPos, this.state.pos);
                        break;
                    }
                    if ((code > 8 && code < 14) ||
                        (code >= 5760 && nonASCIIWhitespace.test(String.fromCharCode(code)))) {
                        string = slice(this.input, startPos, this.state.pos);
                        break;
                    }
                    this.state.pos++;
                }
                else {
                    string = slice(this.input, startPos, this.state.pos);
                    break;
                }
            }
            this.finishToken(nameTok, string);
        };
        Tokenizer.prototype.readIgnoreString = function () {
            var startPos = this.state.pos, prevCode, string = '';
            while (true) {
                var code = this.getCode();
                if (this.state.pos >= this.input.length)
                    break;
                if ((code === 91 || code === 93) && prevCode === 92) {
                    this.state.pos++;
                    prevCode = '';
                }
                else if (code == 93 && prevCode === 93) {
                    string = this.input
                        .slice(startPos, this.state.pos - 1)
                        .replace(/\\([\[\]])/g, '$1');
                    this.state.pos++;
                    break;
                }
                else {
                    this.state.pos++;
                    prevCode = code;
                }
            }
            this.finishToken(ignoreTok, string);
            this.finishToken(bracketDRTok);
        };
        Tokenizer.prototype.finishToken = function (type, value) {
            var preType = this.state.type;
            this.state.type = type;
            if (value !== undefined)
                this.state.value = value;
            this.expectNext(preType, type);
            this.expectPrev(type, preType);
            if (type.updateContext) {
                type.updateContext.call(this, preType);
            }
        };
        Tokenizer.prototype.readToken = function (code, prevCode) {
            if (prevCode === 92) {
                return this.readKeyWord();
            }
            if (this.input.length <= this.state.pos) {
                this.finishToken(eofTok);
            }
            else if (this.curContext() === bracketDContext) {
                this.readIgnoreString();
            }
            else if (code === 123) {
                this.state.pos++;
                this.finishToken(braceLTok);
            }
            else if (code === 125) {
                this.state.pos++;
                this.finishToken(braceRTok);
            }
            else if (code === 42) {
                this.state.pos++;
                if (this.getCode() === 42) {
                    this.state.pos++;
                    return this.finishToken(dbStarTok);
                }
                this.finishToken(starTok);
            }
            else if (code === 33) {
                this.state.pos++;
                this.finishToken(bangTok);
            }
            else if (code === 46) {
                this.state.pos++;
                this.finishToken(dotTok);
            }
            else if (code === 91) {
                this.state.pos++;
                if (this.getCode() === 91) {
                    this.state.pos++;
                    return this.finishToken(bracketDLTok);
                }
                this.finishToken(bracketLTok);
            }
            else if (code === 126) {
                this.state.pos++;
                this.finishToken(expandTok);
            }
            else if (code === 93) {
                this.state.pos++;
                this.finishToken(bracketRTok);
            }
            else if (code === 40) {
                this.state.pos++;
                this.finishToken(parenLTok);
            }
            else if (code === 41) {
                this.state.pos++;
                this.finishToken(parenRTok);
            }
            else if (code === 44) {
                this.state.pos++;
                this.finishToken(commaTok);
            }
            else if (code === 58) {
                this.state.pos++;
                this.finishToken(colonTok);
            }
            else {
                this.readKeyWord();
            }
        };
        return Tokenizer;
    }());

    var isType$1 = function (type) {
        return function (obj) {
            return obj && obj.type === type;
        };
    };
    var isIdentifier = isType$1('Identifier');
    var isIgnoreExpression = isType$1('IgnoreExpression');
    var isDotOperator = isType$1('DotOperator');
    var isWildcardOperator = isType$1('WildcardOperator');
    var isExpandOperator = isType$1('ExpandOperator');
    var isGroupExpression = isType$1('GroupExpression');
    var isRangeExpression = isType$1('RangeExpression');
    var isDestructorExpression = isType$1('DestructorExpression');
    var isObjectPattern = isType$1('ObjectPattern');
    var isArrayPattern = isType$1('ArrayPattern');

    var toString = Object.prototype.toString;
    var isType = function (type) {
        return function (obj) {
            return toString.call(obj) === "[object ".concat(type, "]");
        };
    };
    var isFn = isType('Function');
    var isArr = Array.isArray || isType('Array');
    var isStr = isType('String');
    var isNum = isType('Number');
    var isObj = function (val) { return typeof val === 'object'; };
    var isRegExp = isType('RegExp');
    var isNumberLike = function (t) {
        return isNum(t) || /^(\d+)(\.\d+)?$/.test(t);
    };
    var isArray = isArr;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;
    var toArr = function (val) {
        return Array.isArray(val) ? val : val !== undefined ? [val] : [];
    };
    var isEqual = function (a, b) {
        if (a === b) {
            return true;
        }
        if (a && b && typeof a === 'object' && typeof b === 'object') {
            var arrA = isArray(a);
            var arrB = isArray(b);
            var i = void 0;
            var length_1;
            var key = void 0;
            if (arrA && arrB) {
                length_1 = a.length;
                if (length_1 !== b.length) {
                    return false;
                }
                for (i = length_1; i-- !== 0;) {
                    if (!isEqual(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            }
            if (arrA !== arrB) {
                return false;
            }
            var keys = keyList(a);
            length_1 = keys.length;
            if (length_1 !== keyList(b).length) {
                return false;
            }
            for (i = length_1; i-- !== 0;) {
                if (!hasProp.call(b, keys[i])) {
                    return false;
                }
            }
            for (i = length_1; i-- !== 0;) {
                key = keys[i];
                if (!isEqual(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
        return a !== a && b !== b;
    };
    var isSegmentEqual = function (a, b) {
        a = typeof a === 'symbol' ? a : "".concat(a);
        b = typeof b === 'symbol' ? b : "".concat(b);
        return a === b;
    };

    var DestructorCache = new Map();
    var isValid$1 = function (val) { return val !== undefined && val !== null; };
    var getDestructor = function (source) {
        return DestructorCache.get(source);
    };
    var setDestructor = function (source, rules) {
        DestructorCache.set(source, rules);
    };
    var parseDestructorRules = function (node) {
        var rules = [];
        if (isObjectPattern(node)) {
            var index_1 = 0;
            node.properties.forEach(function (child) {
                rules[index_1] = {
                    path: [],
                };
                rules[index_1].key = child.key.value;
                rules[index_1].path.push(child.key.value);
                if (isIdentifier(child.value)) {
                    rules[index_1].key = child.value.value;
                }
                var basePath = rules[index_1].path;
                var childRules = parseDestructorRules(child.value);
                var k = index_1;
                childRules.forEach(function (rule) {
                    if (rules[k]) {
                        rules[k].key = rule.key;
                        rules[k].path = basePath.concat(rule.path);
                    }
                    else {
                        rules[k] = {
                            key: rule.key,
                            path: basePath.concat(rule.path),
                        };
                    }
                    k++;
                });
                if (k > index_1) {
                    index_1 = k;
                }
                else {
                    index_1++;
                }
            });
            return rules;
        }
        else if (isArrayPattern(node)) {
            var index_2 = 0;
            node.elements.forEach(function (child, key) {
                rules[index_2] = {
                    path: [],
                };
                rules[index_2].key = key;
                rules[index_2].path.push(key);
                if (isIdentifier(child)) {
                    rules[index_2].key = child.value;
                }
                var basePath = rules[index_2].path;
                var childRules = parseDestructorRules(child);
                var k = index_2;
                childRules.forEach(function (rule) {
                    if (rules[k]) {
                        rules[k].key = rule.key;
                        rules[k].path = basePath.concat(rule.path);
                    }
                    else {
                        rules[k] = {
                            key: rule.key,
                            path: basePath.concat(rule.path),
                        };
                    }
                    k++;
                });
                if (k > index_2) {
                    index_2 = k;
                }
                else {
                    index_2++;
                }
            });
            return rules;
        }
        if (isDestructorExpression(node)) {
            return parseDestructorRules(node.value);
        }
        return rules;
    };
    var setInByDestructor = function (source, rules, value, mutators) {
        rules.forEach(function (_a) {
            var key = _a.key, path = _a.path;
            mutators.setIn([key], source, mutators.getIn(path, value));
        });
    };
    var getInByDestructor = function (source, rules, mutators) {
        var response = {};
        if (rules.length) {
            if (isNum(rules[0].path[0])) {
                response = [];
            }
        }
        source = isValid$1(source) ? source : {};
        rules.forEach(function (_a) {
            var key = _a.key, path = _a.path;
            mutators.setIn(path, response, source[key]);
        });
        return response;
    };
    var deleteInByDestructor = function (source, rules, mutators) {
        rules.forEach(function (_a) {
            var key = _a.key;
            mutators.deleteIn([key], source);
        });
    };
    var existInByDestructor = function (source, rules, start, mutators) {
        return rules.every(function (_a) {
            var key = _a.key;
            return mutators.existIn([key], source, start);
        });
    };

    var createTreeBySegments = function (segments, afterNode) {
        if (segments === void 0) { segments = []; }
        var segLen = segments.length;
        var build = function (start) {
            if (start === void 0) { start = 0; }
            var after = start < segLen - 1 ? build(start + 1) : afterNode;
            var dot = after && {
                type: 'DotOperator',
                after: after,
            };
            return {
                type: 'Identifier',
                value: segments[start],
                after: dot,
            };
        };
        return build();
    };
    var calculate = function (a, b, operator) {
        if (isNumberLike(a) && isNumberLike(b)) {
            if (operator === '+')
                return String(Number(a) + Number(b));
            if (operator === '-')
                return String(Number(a) - Number(b));
            if (operator === '*')
                return String(Number(a) * Number(b));
            if (operator === '/')
                return String(Number(a) / Number(b));
        }
        else {
            if (operator === '+')
                return String(a) + String(b);
            if (operator === '-')
                return 'NaN';
            if (operator === '*')
                return 'NaN';
            if (operator === '/')
                return 'NaN';
        }
        return String(Number(b));
    };
    var Parser = /** @class */ (function (_super) {
        __extends(Parser, _super);
        function Parser(input, base) {
            var _this = _super.call(this, input) || this;
            _this.isMatchPattern = false;
            _this.isWildMatchPattern = false;
            _this.haveExcludePattern = false;
            _this.haveRelativePattern = false;
            _this.base = base;
            return _this;
        }
        Parser.prototype.parse = function () {
            var node;
            this.data = {
                segments: [],
            };
            if (!this.eat(eofTok)) {
                this.next();
                node = this.parseAtom(this.state.type);
            }
            this.data.tree = node;
            return node;
        };
        Parser.prototype.append = function (parent, node) {
            if (parent && node) {
                parent.after = node;
            }
        };
        Parser.prototype.parseAtom = function (type) {
            switch (type) {
                case braceLTok:
                case bracketLTok:
                    if (this.includesContext(destructorContext)) {
                        if (type === braceLTok) {
                            return this.parseObjectPattern();
                        }
                        else {
                            return this.parseArrayPattern();
                        }
                    }
                    return this.parseDestructorExpression();
                case nameTok:
                    return this.parseIdentifier();
                case expandTok:
                    return this.parseExpandOperator();
                case dbStarTok:
                case starTok:
                    return this.parseWildcardOperator();
                case bracketDLTok:
                    return this.parseIgnoreExpression();
                case dotTok:
                    return this.parseDotOperator();
            }
        };
        Parser.prototype.pushSegments = function (key) {
            this.data.segments.push(key);
        };
        Parser.prototype.parseIdentifier = function () {
            var node = {
                type: 'Identifier',
                value: this.state.value,
            };
            var hasNotInDestructor = !this.includesContext(destructorContext) &&
                !this.isMatchPattern &&
                !this.isWildMatchPattern;
            this.next();
            if (this.includesContext(bracketArrayContext)) {
                if (this.state.type !== bracketRTok) {
                    throw this.unexpect();
                }
                else {
                    this.state.context.pop();
                    this.next();
                }
            }
            else if (hasNotInDestructor) {
                this.pushSegments(node.value);
            }
            if (this.state.type === bracketLTok) {
                this.next();
                if (this.state.type !== nameTok) {
                    throw this.unexpect();
                }
                this.state.context.push(bracketArrayContext);
                var isNumberKey = false;
                if (/^\d+$/.test(this.state.value)) {
                    isNumberKey = true;
                }
                var value = this.state.value;
                this.pushSegments(isNumberKey ? Number(value) : value);
                var after = this.parseAtom(this.state.type);
                if (isNumberKey) {
                    after.arrayIndex = true;
                }
                this.append(node, after);
            }
            else {
                this.append(node, this.parseAtom(this.state.type));
            }
            return node;
        };
        Parser.prototype.parseExpandOperator = function () {
            var node = {
                type: 'ExpandOperator',
            };
            this.isMatchPattern = true;
            this.isWildMatchPattern = true;
            this.data.segments = [];
            this.next();
            this.append(node, this.parseAtom(this.state.type));
            return node;
        };
        Parser.prototype.parseWildcardOperator = function () {
            var node = {
                type: 'WildcardOperator',
            };
            if (this.state.type === dbStarTok) {
                node.optional = true;
            }
            this.isMatchPattern = true;
            this.isWildMatchPattern = true;
            this.data.segments = [];
            this.next();
            if (this.state.type === parenLTok) {
                node.filter = this.parseGroupExpression(node);
            }
            else if (this.state.type === bracketLTok) {
                node.filter = this.parseRangeExpression(node);
            }
            this.append(node, this.parseAtom(this.state.type));
            return node;
        };
        Parser.prototype.parseDestructorExpression = function () {
            var _this = this;
            var node = {
                type: 'DestructorExpression',
            };
            this.state.context.push(destructorContext);
            var startPos = this.state.pos - 1;
            node.value =
                this.state.type === braceLTok
                    ? this.parseObjectPattern()
                    : this.parseArrayPattern();
            var endPos = this.state.pos;
            this.state.context.pop();
            node.source = this.input
                .substring(startPos, endPos)
                .replace(/\[\s*([\+\-\*\/])?\s*([^,\]\s]*)\s*\]/, function (match, operator, target) {
                if (_this.relative !== undefined) {
                    if (operator) {
                        if (target) {
                            return calculate(_this.relative, target, operator);
                        }
                        else {
                            return calculate(_this.relative, 1, operator);
                        }
                    }
                    else {
                        if (target) {
                            return calculate(_this.relative, target, '+');
                        }
                        else {
                            return String(_this.relative);
                        }
                    }
                }
                return match;
            })
                .replace(/\s*\.\s*/g, '')
                .replace(/\s*/g, '');
            if (this.relative === undefined) {
                setDestructor(node.source, parseDestructorRules(node));
            }
            this.relative = undefined;
            this.pushSegments(node.source);
            this.next();
            this.append(node, this.parseAtom(this.state.type));
            return node;
        };
        Parser.prototype.parseArrayPattern = function () {
            var node = {
                type: 'ArrayPattern',
                elements: [],
            };
            this.next();
            node.elements = this.parseArrayPatternElements();
            return node;
        };
        Parser.prototype.parseArrayPatternElements = function () {
            var nodes = [];
            while (this.state.type !== bracketRTok && this.state.type !== eofTok) {
                nodes.push(this.parseAtom(this.state.type));
                if (this.state.type === bracketRTok) {
                    if (this.includesContext(destructorContext)) {
                        this.next();
                    }
                    return nodes;
                }
                this.next();
            }
            return nodes;
        };
        Parser.prototype.parseObjectPattern = function () {
            var node = {
                type: 'ObjectPattern',
                properties: [],
            };
            this.next();
            node.properties = this.parseObjectProperties();
            return node;
        };
        Parser.prototype.parseObjectProperties = function () {
            var nodes = [];
            while (this.state.type !== braceRTok && this.state.type !== eofTok) {
                var node = {
                    type: 'ObjectPatternProperty',
                    key: this.parseAtom(this.state.type),
                };
                nodes.push(node);
                if (this.state.type === colonTok) {
                    this.next();
                    node.value = this.parseAtom(this.state.type);
                }
                if (this.state.type === braceRTok) {
                    if (this.includesContext(destructorContext)) {
                        this.next();
                    }
                    return nodes;
                }
                this.next();
            }
            return nodes;
        };
        Parser.prototype.parseDotOperator = function () {
            var node = {
                type: 'DotOperator',
            };
            var prevToken = this.type_;
            if (!prevToken && this.base) {
                if (this.base.isMatchPattern) {
                    throw new Error('Base path must be an absolute path.');
                }
                this.data.segments = this.base.toArr();
                while (this.state.type === dotTok) {
                    this.relative = this.data.segments.pop();
                    this.haveRelativePattern = true;
                    this.next();
                }
                return createTreeBySegments(this.data.segments.slice(), this.parseAtom(this.state.type));
            }
            else {
                this.next();
            }
            this.append(node, this.parseAtom(this.state.type));
            return node;
        };
        Parser.prototype.parseIgnoreExpression = function () {
            this.next();
            var value = String(this.state.value).replace(/\s*/g, '');
            var node = {
                type: 'IgnoreExpression',
                value: value,
            };
            this.pushSegments(value);
            this.next();
            this.append(node, this.parseAtom(this.state.type));
            this.next();
            return node;
        };
        Parser.prototype.parseGroupExpression = function (parent) {
            var node = {
                type: 'GroupExpression',
                value: [],
            };
            this.isMatchPattern = true;
            this.data.segments = [];
            this.next();
            loop: while (true) {
                switch (this.state.type) {
                    case commaTok:
                        this.next();
                        break;
                    case bangTok:
                        node.isExclude = true;
                        this.haveExcludePattern = true;
                        this.next();
                        break;
                    case eofTok:
                        break loop;
                    case parenRTok:
                        break loop;
                    default:
                        node.value.push(this.parseAtom(this.state.type));
                }
            }
            this.next();
            this.append(parent, this.parseAtom(this.state.type));
            return node;
        };
        Parser.prototype.parseRangeExpression = function (parent) {
            var node = {
                type: 'RangeExpression',
            };
            this.next();
            this.isMatchPattern = true;
            this.data.segments = [];
            var start = false, hasColon = false;
            loop: while (true) {
                switch (this.state.type) {
                    case colonTok:
                        hasColon = true;
                        start = true;
                        this.next();
                        break;
                    case bracketRTok:
                        if (!hasColon && !node.end) {
                            node.end = node.start;
                        }
                        break loop;
                    case commaTok:
                        throw this.unexpect();
                    case eofTok:
                        break loop;
                    default:
                        if (!start) {
                            node.start = this.parseAtom(this.state.type);
                        }
                        else {
                            node.end = this.parseAtom(this.state.type);
                        }
                }
            }
            this.next();
            this.append(parent, this.parseAtom(this.state.type));
            return node;
        };
        return Parser;
    }(Tokenizer));

    var Matcher = /** @class */ (function () {
        function Matcher(tree, record) {
            this.tree = tree;
            this.stack = [];
            this.excluding = false;
            this.wildcards = [];
            this.record = record;
        }
        Matcher.prototype.next = function (node, pos) {
            //  const isOverToken = pos > this.path.length
            if (node.after) {
                // if (isOverToken) {
                //   return false
                // }
                return this.matchNode(node.after, pos);
            }
            if (isWildcardOperator(node) && !node.filter) {
                if (this.excluding) {
                    return false;
                }
                else {
                    if (pos === 0 || node.optional)
                        return true;
                    return !!this.take(pos);
                }
            }
            var isLastToken = pos === this.path.length - 1;
            if (isLastToken) {
                return !!this.take(pos);
            }
            else {
                var wildcard = this.wildcards.pop();
                if (wildcard && wildcard.after) {
                    return this.next(wildcard, pos);
                }
            }
            return false;
        };
        Matcher.prototype.shot = function () {
            var _a;
            if (((_a = this.record) === null || _a === void 0 ? void 0 : _a.score) >= 0) {
                this.record.score++;
            }
        };
        Matcher.prototype.take = function (pos) {
            var _a;
            return String((_a = this.path[pos]) !== null && _a !== void 0 ? _a : '');
        };
        Matcher.prototype.matchExcludeIdentifier = function (matched, node, pos) {
            var isLastToken = pos === this.path.length - 1;
            var isContainToken = pos < this.path.length;
            if (!node.after) {
                this.excluding = false;
            }
            if (matched) {
                if (node.after) {
                    return this.next(node, pos);
                }
                if (isLastToken) {
                    return false;
                }
            }
            if (isLastToken) {
                return true;
            }
            return isContainToken;
        };
        Matcher.prototype.matchIdentifier = function (node, pos) {
            var current = this.take(pos);
            var matched = false;
            if (isExpandOperator(node.after)) {
                if (current.indexOf(node.value) === 0) {
                    this.shot();
                    matched = true;
                }
                if (this.excluding) {
                    return this.matchExcludeIdentifier(matched, node.after, pos);
                }
                else {
                    return matched && this.next(node.after, pos);
                }
            }
            else if (current === node.value) {
                this.shot();
                matched = true;
            }
            if (this.excluding) {
                return this.matchExcludeIdentifier(matched, node, pos);
            }
            else {
                return matched && this.next(node, pos);
            }
        };
        Matcher.prototype.matchIgnoreExpression = function (node, pos) {
            return isEqual(node.value, this.take(pos)) && this.next(node, pos);
        };
        Matcher.prototype.matchDestructorExpression = function (node, pos) {
            return isEqual(node.source, this.take(pos)) && this.next(node, pos);
        };
        Matcher.prototype.matchExpandOperator = function (node, pos) {
            return this.next(node, pos);
        };
        Matcher.prototype.matchWildcardOperator = function (node, pos) {
            var matched = false;
            if (node.filter) {
                this.stack.push(node);
                matched = this.matchNode(node.filter, pos);
                this.stack.pop();
            }
            else {
                matched = this.next(node, pos);
            }
            return matched;
        };
        Matcher.prototype.matchGroupExpression = function (node, pos) {
            var _this = this;
            var excluding = false;
            if (node.isExclude) {
                excluding = !this.excluding;
            }
            return toArr(node.value)[excluding ? 'every' : 'some'](function (item) {
                _this.wildcards = _this.stack.slice();
                _this.excluding = excluding;
                return _this.matchNode(item, pos);
            });
        };
        Matcher.prototype.matchRangeExpression = function (node, pos) {
            var current = Number(this.take(pos));
            if (node.start) {
                if (node.end) {
                    return (current >= Number(node.start.value) &&
                        current <= Number(node.end.value));
                }
                else {
                    return current >= Number(node.start.value);
                }
            }
            else {
                if (node.end) {
                    return current <= Number(node.end.value);
                }
                else {
                    this.wildcards = this.stack.slice();
                    return this.next(node, pos);
                }
            }
        };
        Matcher.prototype.matchNode = function (node, pos) {
            if (pos === void 0) { pos = 0; }
            if (isDotOperator(node)) {
                return this.next(node, pos + 1);
            }
            else if (isIdentifier(node)) {
                return this.matchIdentifier(node, pos);
            }
            else if (isIgnoreExpression(node)) {
                return this.matchIgnoreExpression(node, pos);
            }
            else if (isDestructorExpression(node)) {
                return this.matchDestructorExpression(node, pos);
            }
            else if (isExpandOperator(node)) {
                return this.matchExpandOperator(node, pos);
            }
            else if (isWildcardOperator(node)) {
                return this.matchWildcardOperator(node, pos);
            }
            else if (isGroupExpression(node)) {
                return this.matchGroupExpression(node, pos);
            }
            else if (isRangeExpression(node)) {
                return this.matchRangeExpression(node, pos);
            }
            return false;
        };
        Matcher.prototype.match = function (path) {
            this.path = path;
            return { matched: this.matchNode(this.tree), record: this.record };
        };
        Matcher.matchSegments = function (source, target, record) {
            if (source.length !== target.length)
                return { matched: false, record: record };
            var match = function (pos) {
                if (pos === void 0) { pos = 0; }
                var current = isSegmentEqual(source[pos], target[pos]);
                if ((record === null || record === void 0 ? void 0 : record.score) >= 0) {
                    record.score++;
                }
                return current && (pos < source.length - 1 ? match(pos + 1) : true);
            };
            return { matched: match(), record: record };
        };
        return Matcher;
    }());

    var pathCache = new Map();
    var isMatcher = Symbol('PATH_MATCHER');
    var isValid = function (val) { return val !== undefined && val !== null; };
    var isSimplePath = function (val) {
        return val.indexOf('*') === -1 &&
            val.indexOf('~') === -1 &&
            val.indexOf('[') === -1 &&
            val.indexOf(']') === -1 &&
            val.indexOf(',') === -1 &&
            val.indexOf(':') === -1 &&
            val.indexOf(' ') === -1 &&
            val[0] !== '.';
    };
    var isAssignable = function (val) {
        return typeof val === 'object' || typeof val === 'function';
    };
    var isNumberIndex = function (val) {
        return isStr(val) ? /^\d+$/.test(val) : isNum(val);
    };
    var getIn = function (segments, source) {
        for (var i = 0; i < segments.length; i++) {
            var index = segments[i];
            var rules = getDestructor(index);
            if (!rules) {
                if (!isValid(source))
                    return;
                source = source[index];
            }
            else {
                source = getInByDestructor(source, rules, { setIn: setIn, getIn: getIn });
                break;
            }
        }
        return source;
    };
    var setIn = function (segments, source, value) {
        for (var i = 0; i < segments.length; i++) {
            var index = segments[i];
            var rules = getDestructor(index);
            if (!rules) {
                if (!isValid(source) || !isAssignable(source))
                    return;
                if (isArr(source) && !isNumberIndex(index)) {
                    return;
                }
                if (!isValid(source[index])) {
                    if (value === undefined) {
                        if (source[index] === null)
                            source[index] = value;
                        return;
                    }
                    if (i < segments.length - 1) {
                        source[index] = isNum(segments[i + 1]) ? [] : {};
                    }
                }
                if (i === segments.length - 1) {
                    source[index] = value;
                }
                source = source[index];
            }
            else {
                setInByDestructor(source, rules, value, { setIn: setIn, getIn: getIn });
                break;
            }
        }
    };
    var deleteIn = function (segments, source) {
        for (var i = 0; i < segments.length; i++) {
            var index = segments[i];
            var rules = getDestructor(index);
            if (!rules) {
                if (i === segments.length - 1 && isValid(source)) {
                    delete source[index];
                    return;
                }
                if (!isValid(source) || !isAssignable(source))
                    return;
                source = source[index];
                if (!isObj(source)) {
                    return;
                }
            }
            else {
                deleteInByDestructor(source, rules, {
                    setIn: setIn,
                    getIn: getIn,
                    deleteIn: deleteIn,
                });
                break;
            }
        }
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var existIn = function (segments, source, start) {
        if (start instanceof Path) {
            start = start.length;
        }
        for (var i = start; i < segments.length; i++) {
            var index = segments[i];
            var rules = getDestructor(index);
            if (!rules) {
                if (i === segments.length - 1) {
                    return hasOwnProperty.call(source, index);
                }
                if (!isValid(source) || !isAssignable(source))
                    return false;
                source = source[index];
                if (!isObj(source)) {
                    return false;
                }
            }
            else {
                return existInByDestructor(source, rules, start, {
                    setIn: setIn,
                    getIn: getIn,
                    deleteIn: deleteIn,
                    existIn: existIn,
                });
            }
        }
    };
    var parse = function (pattern, base) {
        if (pattern instanceof Path) {
            return {
                entire: pattern.entire,
                segments: pattern.segments.slice(),
                isRegExp: false,
                haveRelativePattern: pattern.haveRelativePattern,
                isWildMatchPattern: pattern.isWildMatchPattern,
                isMatchPattern: pattern.isMatchPattern,
                haveExcludePattern: pattern.haveExcludePattern,
                tree: pattern.tree,
            };
        }
        else if (isStr(pattern)) {
            if (!pattern) {
                return {
                    entire: '',
                    segments: [],
                    isRegExp: false,
                    isWildMatchPattern: false,
                    haveExcludePattern: false,
                    isMatchPattern: false,
                };
            }
            if (isSimplePath(pattern)) {
                return {
                    entire: pattern,
                    segments: pattern.split('.'),
                    isRegExp: false,
                    isWildMatchPattern: false,
                    haveExcludePattern: false,
                    isMatchPattern: false,
                };
            }
            var parser = new Parser(pattern, Path.parse(base));
            var tree = parser.parse();
            if (!parser.isMatchPattern) {
                var segments = parser.data.segments;
                return {
                    entire: segments.join('.'),
                    segments: segments,
                    tree: tree,
                    isRegExp: false,
                    haveRelativePattern: parser.haveRelativePattern,
                    isWildMatchPattern: false,
                    haveExcludePattern: false,
                    isMatchPattern: false,
                };
            }
            else {
                return {
                    entire: pattern,
                    segments: [],
                    isRegExp: false,
                    haveRelativePattern: false,
                    isWildMatchPattern: parser.isWildMatchPattern,
                    haveExcludePattern: parser.haveExcludePattern,
                    isMatchPattern: true,
                    tree: tree,
                };
            }
        }
        else if (isFn(pattern) && pattern[isMatcher]) {
            return parse(pattern['path']);
        }
        else if (isArr(pattern)) {
            return {
                entire: pattern.join('.'),
                segments: pattern.reduce(function (buf, key) {
                    return buf.concat(parseString(key));
                }, []),
                isRegExp: false,
                haveRelativePattern: false,
                isWildMatchPattern: false,
                haveExcludePattern: false,
                isMatchPattern: false,
            };
        }
        else if (isRegExp(pattern)) {
            return {
                entire: pattern,
                segments: [],
                isRegExp: true,
                haveRelativePattern: false,
                isWildMatchPattern: false,
                haveExcludePattern: false,
                isMatchPattern: true,
            };
        }
        else {
            return {
                entire: '',
                isRegExp: false,
                segments: pattern !== undefined ? [pattern] : [],
                haveRelativePattern: false,
                isWildMatchPattern: false,
                haveExcludePattern: false,
                isMatchPattern: false,
            };
        }
    };
    var parseString = function (source) {
        if (isStr(source)) {
            source = source.replace(/\s*/g, '');
            try {
                var _a = parse(source), segments = _a.segments, isMatchPattern = _a.isMatchPattern;
                return !isMatchPattern ? segments : source;
            }
            catch (e) {
                return source;
            }
        }
        else if (source instanceof Path) {
            return source.segments;
        }
        return source;
    };
    var Path = /** @class */ (function () {
        function Path(input, base) {
            var _this = this;
            this.concat = function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (_this.isMatchPattern || _this.isRegExp) {
                    throw new Error("".concat(_this.entire, " cannot be concat"));
                }
                var path = new Path('');
                path.segments = (_a = _this.segments).concat.apply(_a, __spreadArray([], __read(args.map(function (s) { return parseString(s); }))));
                path.entire = path.segments.join('.');
                return path;
            };
            this.slice = function (start, end) {
                if (_this.isMatchPattern || _this.isRegExp) {
                    throw new Error("".concat(_this.entire, " cannot be slice"));
                }
                var path = new Path('');
                path.segments = _this.segments.slice(start, end);
                path.entire = path.segments.join('.');
                return path;
            };
            this.push = function () {
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                return _this.concat.apply(_this, __spreadArray([], __read(items)));
            };
            this.pop = function () {
                if (_this.isMatchPattern || _this.isRegExp) {
                    throw new Error("".concat(_this.entire, " cannot be pop"));
                }
                return new Path(_this.segments.slice(0, _this.segments.length - 1));
            };
            this.splice = function (start, deleteCount) {
                var items = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    items[_i - 2] = arguments[_i];
                }
                if (_this.isMatchPattern || _this.isRegExp) {
                    throw new Error("".concat(_this.entire, " cannot be splice"));
                }
                items = items.reduce(function (buf, item) { return buf.concat(parseString(item)); }, []);
                var segments_ = _this.segments.slice();
                segments_.splice.apply(segments_, __spreadArray([start, deleteCount], __read(items)));
                return new Path(segments_);
            };
            this.forEach = function (callback) {
                if (_this.isMatchPattern || _this.isRegExp) {
                    throw new Error("".concat(_this.entire, " cannot be each"));
                }
                _this.segments.forEach(callback);
            };
            this.map = function (callback) {
                if (_this.isMatchPattern || _this.isRegExp) {
                    throw new Error("".concat(_this.entire, " cannot be map"));
                }
                return _this.segments.map(callback);
            };
            this.reduce = function (callback, initial) {
                if (_this.isMatchPattern || _this.isRegExp) {
                    throw new Error("".concat(_this.entire, " cannot be reduce"));
                }
                return _this.segments.reduce(callback, initial);
            };
            this.parent = function () {
                return _this.slice(0, _this.length - 1);
            };
            this.includes = function (pattern) {
                var _a = Path.parse(pattern), entire = _a.entire, segments = _a.segments, isMatchPattern = _a.isMatchPattern;
                var cache = _this.includesCache.get(entire);
                if (cache !== undefined)
                    return cache;
                var cacheWith = function (value) {
                    _this.includesCache.set(entire, value);
                    return value;
                };
                if (_this.isMatchPattern) {
                    if (!isMatchPattern) {
                        return cacheWith(_this.match(segments));
                    }
                    else {
                        throw new Error("".concat(_this.entire, " cannot be used to match ").concat(entire));
                    }
                }
                if (isMatchPattern) {
                    throw new Error("".concat(_this.entire, " cannot be used to match ").concat(entire));
                }
                if (segments.length > _this.segments.length)
                    return cacheWith(false);
                for (var i = 0; i < segments.length; i++) {
                    if (!isEqual(String(segments[i]), String(_this.segments[i]))) {
                        return cacheWith(false);
                    }
                }
                return cacheWith(true);
            };
            this.transform = function (regexp, callback) {
                if (!isFn(callback))
                    return '';
                if (_this.isMatchPattern) {
                    throw new Error("".concat(_this.entire, " cannot be transformed"));
                }
                var args = _this.segments.reduce(function (buf, key) {
                    return new RegExp(regexp).test(key) ? buf.concat(key) : buf;
                }, []);
                return callback.apply(void 0, __spreadArray([], __read(args)));
            };
            this.match = function (pattern) {
                var _a, _b;
                var path = Path.parse(pattern);
                var cache = _this.matchCache.get(path.entire);
                if (cache !== undefined) {
                    if (cache.record && cache.record.score !== undefined) {
                        _this.matchScore = cache.record.score;
                    }
                    return cache.matched;
                }
                var cacheWith = function (value) {
                    _this.matchCache.set(path.entire, value);
                    return value;
                };
                if (path.isMatchPattern) {
                    if (_this.isMatchPattern) {
                        throw new Error("".concat(path.entire, " cannot match ").concat(_this.entire));
                    }
                    else {
                        _this.matchScore = 0;
                        return cacheWith(path.match(_this.segments));
                    }
                }
                else {
                    if (_this.isMatchPattern) {
                        if (_this.isRegExp) {
                            try {
                                return (_b = (_a = _this['entire']) === null || _a === void 0 ? void 0 : _a['test']) === null || _b === void 0 ? void 0 : _b.call(_a, path.entire);
                            }
                            finally {
                                _this.entire.lastIndex = 0;
                            }
                        }
                        var record = {
                            score: 0,
                        };
                        var result = cacheWith(new Matcher(_this.tree, record).match(path.segments));
                        _this.matchScore = record.score;
                        return result.matched;
                    }
                    else {
                        var record = {
                            score: 0,
                        };
                        var result = cacheWith(Matcher.matchSegments(_this.segments, path.segments, record));
                        _this.matchScore = record.score;
                        return result.matched;
                    }
                }
            };
            //
            this.matchAliasGroup = function (name, alias) {
                var namePath = Path.parse(name);
                var aliasPath = Path.parse(alias);
                var nameMatched = _this.match(namePath);
                var nameMatchedScore = _this.matchScore;
                var aliasMatched = _this.match(aliasPath);
                var aliasMatchedScore = _this.matchScore;
                if (_this.haveExcludePattern) {
                    if (nameMatchedScore >= aliasMatchedScore) {
                        return nameMatched;
                    }
                    else {
                        return aliasMatched;
                    }
                }
                else {
                    return nameMatched || aliasMatched;
                }
            };
            this.existIn = function (source, start) {
                if (start === void 0) { start = 0; }
                return existIn(_this.segments, source, start);
            };
            this.getIn = function (source) {
                return getIn(_this.segments, source);
            };
            this.setIn = function (source, value) {
                setIn(_this.segments, source, value);
                return source;
            };
            this.deleteIn = function (source) {
                deleteIn(_this.segments, source);
                return source;
            };
            this.ensureIn = function (source, defaults) {
                var results = _this.getIn(source);
                if (results === undefined) {
                    _this.setIn(source, defaults);
                    return _this.getIn(source);
                }
                return results;
            };
            var _a = parse(input, base), tree = _a.tree, segments = _a.segments, entire = _a.entire, isRegExp = _a.isRegExp, isMatchPattern = _a.isMatchPattern, isWildMatchPattern = _a.isWildMatchPattern, haveRelativePattern = _a.haveRelativePattern, haveExcludePattern = _a.haveExcludePattern;
            this.entire = entire;
            this.segments = segments;
            this.isMatchPattern = isMatchPattern;
            this.isWildMatchPattern = isWildMatchPattern;
            this.haveRelativePattern = haveRelativePattern;
            this.isRegExp = isRegExp;
            this.haveExcludePattern = haveExcludePattern;
            this.tree = tree;
            this.matchCache = new Map();
            this.includesCache = new Map();
        }
        Path.prototype.toString = function () {
            var _a;
            return (_a = this.entire) === null || _a === void 0 ? void 0 : _a.toString();
        };
        Path.prototype.toArr = function () {
            var _a;
            return (_a = this.segments) === null || _a === void 0 ? void 0 : _a.slice();
        };
        Object.defineProperty(Path.prototype, "length", {
            get: function () {
                return this.segments.length;
            },
            enumerable: false,
            configurable: true
        });
        Path.match = function (pattern) {
            var path = Path.parse(pattern);
            var matcher = function (target) {
                return path.match(target);
            };
            matcher[isMatcher] = true;
            matcher.path = path;
            return matcher;
        };
        Path.isPathPattern = function (target) {
            return !!(isStr(target) ||
                isArr(target) ||
                isRegExp(target) ||
                (isFn(target) && target[isMatcher]));
        };
        Path.transform = function (pattern, regexp, callback) {
            return Path.parse(pattern).transform(regexp, callback);
        };
        Path.parse = function (path, base) {
            if (path === void 0) { path = ''; }
            if (path instanceof Path) {
                var found = pathCache.get(path.entire);
                if (found) {
                    return found;
                }
                else {
                    pathCache.set(path.entire, path);
                    return path;
                }
            }
            else if (path && path[isMatcher]) {
                return Path.parse(path['path']);
            }
            else {
                var key_ = base ? Path.parse(base) : '';
                var key = "".concat(path, ":").concat(key_);
                var found = pathCache.get(key);
                if (found) {
                    return found;
                }
                else {
                    path = new Path(path, base);
                    pathCache.set(key, path);
                    return path;
                }
            }
        };
        Path.getIn = function (source, pattern) {
            var path = Path.parse(pattern);
            return path.getIn(source);
        };
        Path.setIn = function (source, pattern, value) {
            var path = Path.parse(pattern);
            return path.setIn(source, value);
        };
        Path.deleteIn = function (source, pattern) {
            var path = Path.parse(pattern);
            return path.deleteIn(source);
        };
        Path.existIn = function (source, pattern, start) {
            var path = Path.parse(pattern);
            return path.existIn(source, start);
        };
        Path.ensureIn = function (source, pattern, defaultValue) {
            var path = Path.parse(pattern);
            return path.ensureIn(source, defaultValue);
        };
        return Path;
    }());

    exports.Path = Path;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=formily.path.umd.development.js.map

  </script>

  <script id="shared-script">
    (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('formily.shared', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Formily = global.Formily || {}, global.Formily.Shared = {})));
})(this, (function (exports) { 'use strict';

    (function() {
        const env = {"NODE_ENV":"development"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    var toString$1 = Object.prototype.toString;
    var isType = function (type) {
        return function (obj) {
            return getType(obj) === "[object ".concat(type, "]");
        };
    };
    var getType = function (obj) { return toString$1.call(obj); };
    var isFn = function (val) { return typeof val === 'function'; };
    var isArr = Array.isArray;
    var isPlainObj = isType('Object');
    var isStr = isType('String');
    var isBool = isType('Boolean');
    var isNum = isType('Number');
    var isMap = function (val) {
        return val && val instanceof Map;
    };
    var isSet = function (val) { return val && val instanceof Set; };
    var isWeakMap = function (val) {
        return val && val instanceof WeakMap;
    };
    var isWeakSet = function (val) {
        return val && val instanceof WeakSet;
    };
    var isNumberLike = function (index) {
        return isNum(index) || /^\d+$/.test(index);
    };
    var isObj = function (val) { return typeof val === 'object'; };
    var isRegExp = isType('RegExp');
    var isReactElement = function (obj) {
        return obj && obj['$$typeof'] && obj['_owner'];
    };
    var isHTMLElement = function (target) {
        return Object.prototype.toString.call(target).indexOf('HTML') > -1;
    };

    var toArr = function (val) { return (isArr(val) ? val : val ? [val] : []); };
    function each(val, iterator, revert) {
        if (isArr(val) || isStr(val)) {
            if (revert) {
                for (var i = val.length - 1; i >= 0; i--) {
                    if (iterator(val[i], i) === false) {
                        return;
                    }
                }
            }
            else {
                for (var i = 0; i < val.length; i++) {
                    if (iterator(val[i], i) === false) {
                        return;
                    }
                }
            }
        }
        else if (isObj(val)) {
            var key = void 0;
            for (key in val) {
                if (Object.hasOwnProperty.call(val, key)) {
                    if (iterator(val[key], key) === false) {
                        return;
                    }
                }
            }
        }
    }
    function map(val, iterator, revert) {
        var res = isArr(val) || isStr(val) ? [] : {};
        each(val, function (item, key) {
            var value = iterator(item, key);
            if (isArr(res)) {
                res.push(value);
            }
            else {
                res[key] = value;
            }
        }, revert);
        return res;
    }
    function reduce(val, iterator, accumulator, revert) {
        var result = accumulator;
        each(val, function (item, key) {
            result = iterator(result, item, key);
        }, revert);
        return result;
    }
    function every(val, iterator, revert) {
        var res = true;
        each(val, function (item, key) {
            if (!iterator(item, key)) {
                res = false;
                return false;
            }
        }, revert);
        return res;
    }
    function some(val, iterator, revert) {
        var res = false;
        each(val, function (item, key) {
            if (iterator(item, key)) {
                res = true;
                return false;
            }
        }, revert);
        return res;
    }
    function findIndex(val, iterator, revert) {
        var res = -1;
        each(val, function (item, key) {
            if (iterator(item, key)) {
                res = key;
                return false;
            }
        }, revert);
        return res;
    }
    function find(val, iterator, revert) {
        var res;
        each(val, function (item, key) {
            if (iterator(item, key)) {
                res = item;
                return false;
            }
        }, revert);
        return res;
    }
    function includes(val, searchElement, revert) {
        if (isStr(val))
            return val.includes(searchElement);
        return some(val, function (item) { return item === searchElement; }, revert);
    }

    /* istanbul ignore next */
    function globalSelf() {
        try {
            if (typeof self !== 'undefined') {
                return self;
            }
        }
        catch (e) { }
        try {
            if (typeof window !== 'undefined') {
                return window;
            }
        }
        catch (e) { }
        try {
            if (typeof global !== 'undefined') {
                return global;
            }
        }
        catch (e) { }
        return Function('return this')();
    }
    var globalThisPolyfill = globalSelf();

    var instOf = function (value, cls) {
        if (isFn(cls))
            return value instanceof cls;
        if (isStr(cls))
            return globalThisPolyfill[cls]
                ? value instanceof globalThisPolyfill[cls]
                : false;
        return false;
    };

    var isArray = isArr;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;
    /* eslint-disable */
    function equal(a, b) {
        // fast-deep-equal index.js 2.0.1
        if (a === b) {
            return true;
        }
        if (a && b && typeof a === 'object' && typeof b === 'object') {
            var arrA = isArray(a);
            var arrB = isArray(b);
            var i = void 0;
            var length_1;
            var key = void 0;
            if (arrA && arrB) {
                length_1 = a.length;
                if (length_1 !== b.length) {
                    return false;
                }
                for (i = length_1; i-- !== 0;) {
                    if (!equal(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            }
            if (arrA !== arrB) {
                return false;
            }
            var momentA = a && a._isAMomentObject;
            var momentB = b && b._isAMomentObject;
            if (momentA !== momentB)
                return false;
            if (momentA && momentB)
                return a.isSame(b);
            var immutableA = a && a.toJS;
            var immutableB = b && b.toJS;
            if (immutableA !== immutableB)
                return false;
            if (immutableA)
                return a.is ? a.is(b) : a === b;
            var dateA = instOf(a, 'Date');
            var dateB = instOf(b, 'Date');
            if (dateA !== dateB) {
                return false;
            }
            if (dateA && dateB) {
                return a.getTime() === b.getTime();
            }
            var regexpA = instOf(a, 'RegExp');
            var regexpB = instOf(b, 'RegExp');
            if (regexpA !== regexpB) {
                return false;
            }
            if (regexpA && regexpB) {
                return a.toString() === b.toString();
            }
            var urlA = instOf(a, 'URL');
            var urlB = instOf(b, 'URL');
            if (urlA !== urlB) {
                return false;
            }
            if (urlA && urlB) {
                return a.href === b.href;
            }
            var schemaA = a && a.toJSON;
            var schemaB = b && b.toJSON;
            if (schemaA !== schemaB)
                return false;
            if (schemaA && schemaB)
                return equal(a.toJSON(), b.toJSON());
            var keys = keyList(a);
            length_1 = keys.length;
            if (length_1 !== keyList(b).length) {
                return false;
            }
            for (i = length_1; i-- !== 0;) {
                if (!hasProp.call(b, keys[i])) {
                    return false;
                }
            }
            // end fast-deep-equal
            // Custom handling for React
            for (i = length_1; i-- !== 0;) {
                key = keys[i];
                if (key === '_owner' && a.$$typeof) {
                    // React-specific: avoid traversing React elements' _owner.
                    //  _owner contains circular references
                    // and is not needed when comparing the actual elements (and not their owners)
                    // .$$typeof and ._store on just reasonable markers of a react element
                    continue;
                }
                else {
                    // all other properties should be traversed as usual
                    if (!equal(a[key], b[key])) {
                        return false;
                    }
                }
            }
            // fast-deep-equal index.js 2.0.1
            return true;
        }
        return a !== a && b !== b;
    }
    // end fast-deep-equal
    var isEqual = function exportedEqual(a, b) {
        try {
            return equal(a, b);
        }
        catch (error) {
            /* istanbul ignore next */
            if ((error.message && error.message.match(/stack|recursion/i)) ||
                error.number === -2146828260) {
                // warn on circular references, don't crash
                // browsers give this different errors name and messages:
                // chrome/safari: "RangeError", "Maximum call stack size exceeded"
                // firefox: "InternalError", too much recursion"
                // edge: "Error", "Out of stack space"
                console.warn('Warning: react-fast-compare does not handle circular references.', error.name, error.message);
                return false;
            }
            // some other error. we should definitely know about these
            /* istanbul ignore next */
            throw error;
        }
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    var shallowClone = function (values) {
        if (Array.isArray(values)) {
            return values.slice(0);
        }
        else if (isPlainObj(values)) {
            if ('$$typeof' in values && '_owner' in values) {
                return values;
            }
            if (values['_isAMomentObject']) {
                return values;
            }
            if (values['_isJSONSchemaObject']) {
                return values;
            }
            if (isFn(values['toJS'])) {
                return values;
            }
            if (isFn(values['toJSON'])) {
                return values;
            }
            return __assign({}, values);
        }
        else if (typeof values === 'object') {
            return new values.constructor(values);
        }
        return values;
    };
    var clone = function (values) {
        if (Array.isArray(values)) {
            var res_1 = [];
            values.forEach(function (item) {
                res_1.push(clone(item));
            });
            return res_1;
        }
        else if (isPlainObj(values)) {
            if ('$$typeof' in values && '_owner' in values) {
                return values;
            }
            if (values['_isAMomentObject']) {
                return values;
            }
            if (values['_isJSONSchemaObject']) {
                return values;
            }
            if (isFn(values['toJS'])) {
                return values['toJS']();
            }
            if (isFn(values['toJSON'])) {
                return values['toJSON']();
            }
            var res = {};
            for (var key in values) {
                if (Object.hasOwnProperty.call(values, key)) {
                    res[key] = clone(values[key]);
                }
            }
            return res;
        }
        else {
            return values;
        }
    };

    var has = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    var isUndef = function (val) { return val === undefined; };
    var isValid = function (val) { return val !== undefined && val !== null; };
    function isEmpty(val, strict) {
        if (strict === void 0) { strict = false; }
        // Null and Undefined...
        if (val == null) {
            return true;
        }
        // Booleans...
        if (typeof val === 'boolean') {
            return false;
        }
        // Numbers...
        if (typeof val === 'number') {
            return false;
        }
        // Strings...
        if (typeof val === 'string') {
            return val.length === 0;
        }
        // Functions...
        if (typeof val === 'function') {
            return val.length === 0;
        }
        // Arrays...
        if (Array.isArray(val)) {
            if (val.length === 0) {
                return true;
            }
            for (var i = 0; i < val.length; i++) {
                if (strict) {
                    if (val[i] !== undefined && val[i] !== null) {
                        return false;
                    }
                }
                else {
                    if (val[i] !== undefined &&
                        val[i] !== null &&
                        val[i] !== '' &&
                        val[i] !== 0) {
                        return false;
                    }
                }
            }
            return true;
        }
        // Errors...
        if (instOf(val, 'Error')) {
            return val.message === '';
        }
        // Objects...
        if (val.toString === toString) {
            switch (val.toString()) {
                // Maps, Sets, Files and Errors...
                case '[object File]':
                case '[object Map]':
                case '[object Set]': {
                    return val.size === 0;
                }
                // Plain objects...
                case '[object Object]': {
                    for (var key in val) {
                        if (has.call(val, key)) {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        // Anything else...
        return false;
    }

    /**
     * Lower case as a function.
     */
    function lowerCase(str) {
        return str.toLowerCase();
    }

    // Support camel case ("camelCase" -> "camel Case" and "CAMELCase" -> "CAMEL Case").
    var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
    // Remove all non-word characters.
    var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    /**
     * Normalize the string into something other libraries can manipulate easier.
     */
    function noCase(input, options) {
        if (options === void 0) { options = {}; }
        var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lowerCase : _c, _d = options.delimiter, delimiter = _d === void 0 ? " " : _d;
        var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
        var start = 0;
        var end = result.length;
        // Trim the delimiter from around the output string.
        while (result.charAt(start) === "\0")
            start++;
        while (result.charAt(end - 1) === "\0")
            end--;
        // Transform each token independently.
        return result.slice(start, end).split("\0").map(transform).join(delimiter);
    }
    /**
     * Replace `re` in the input string with the replacement value.
     */
    function replace(input, re, value) {
        if (re instanceof RegExp)
            return input.replace(re, value);
        return re.reduce(function (input, re) { return input.replace(re, value); }, input);
    }

    function pascalCaseTransform(input, index) {
        var firstChar = input.charAt(0);
        var lowerChars = input.substr(1).toLowerCase();
        if (index > 0 && firstChar >= "0" && firstChar <= "9") {
            return "_" + firstChar + lowerChars;
        }
        return "" + firstChar.toUpperCase() + lowerChars;
    }
    function pascalCase(input, options) {
        if (options === void 0) { options = {}; }
        return noCase(input, __assign({ delimiter: "", transform: pascalCaseTransform }, options));
    }

    function camelCaseTransform(input, index) {
        if (index === 0)
            return input.toLowerCase();
        return pascalCaseTransform(input, index);
    }
    function camelCase(input, options) {
        if (options === void 0) { options = {}; }
        return pascalCase(input, __assign({ transform: camelCaseTransform }, options));
    }

    /**
     * Upper case as a function.
     */
    function upperCase(str) {
        return str.toUpperCase();
    }

    function dotCase(input, options) {
        if (options === void 0) { options = {}; }
        return noCase(input, __assign({ delimiter: "." }, options));
    }

    function paramCase(input, options) {
        if (options === void 0) { options = {}; }
        return dotCase(input, __assign({ delimiter: "-" }, options));
    }

    // ansiRegex
    var ansiRegex = function () {
        var pattern = [
            '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)',
            '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))',
        ].join('|');
        return new RegExp(pattern, 'g');
    };
    // astralRegex
    var regex = '[\uD800-\uDBFF][\uDC00-\uDFFF]';
    var astralRegex = function (opts) {
        return opts && opts.exact ? new RegExp("^".concat(regex, "$")) : new RegExp(regex, 'g');
    };
    // stripAnsi
    var stripAnsi = function (input) {
        return typeof input === 'string' ? input.replace(ansiRegex(), '') : input;
    };
    var stringLength = function (input) {
        return stripAnsi(input).replace(astralRegex(), ' ').length;
    };

    const _global_Formily_Path_Path = Formily.Path.Path;

    var caches = {};
    function deprecate(method, message, help) {
        if (isFn(method)) {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            return function (p1, p2, p3, p4, p5) {
                deprecate(message, help);
                return method.apply(this, arguments);
            };
        }
        if (isStr(method) && !caches[method]) {
            caches[method] = true;
            console.warn(new Error("".concat(method, " has been deprecated. Do not continue to use this api.").concat(message || '')));
        }
    }

    var Subscribable = /** @class */ (function () {
        function Subscribable() {
            var _this = this;
            this.subscribers = {
                index: 0,
            };
            this.subscribe = function (callback) {
                if (isFn(callback)) {
                    var index = _this.subscribers.index + 1;
                    _this.subscribers[index] = callback;
                    _this.subscribers.index++;
                    return index;
                }
            };
            this.unsubscribe = function (index) {
                if (_this.subscribers[index]) {
                    delete _this.subscribers[index];
                }
                else if (!index) {
                    _this.subscribers = {
                        index: 0,
                    };
                }
            };
            this.notify = function (payload, silent) {
                if (_this.subscription) {
                    if (_this.subscription && isFn(_this.subscription.notify)) {
                        if (_this.subscription.notify.call(_this, payload) === false) {
                            return;
                        }
                    }
                }
                if (silent)
                    return;
                var filter = function (payload) {
                    if (_this.subscription && isFn(_this.subscription.filter)) {
                        return _this.subscription.filter.call(_this, payload);
                    }
                    return payload;
                };
                each(_this.subscribers, function (callback) {
                    if (isFn(callback))
                        callback(filter(payload));
                });
            };
        }
        return Subscribable;
    }());

    var applyMiddleware = function (payload, fns) {
        if (fns === void 0) { fns = []; }
        var compose = function (payload, fns) {
            var prevPayload = payload;
            return Promise.resolve(fns[0](payload, function (payload) {
                return compose(payload !== null && payload !== void 0 ? payload : prevPayload, fns.slice(1));
            }));
        };
        return new Promise(function (resolve, reject) {
            compose(payload, fns.concat(function (payload) {
                resolve(payload);
            })).catch(reject);
        });
    };

    function defaultIsMergeableObject(value) {
        return isNonNullObject(value) && !isSpecial(value);
    }
    function isNonNullObject(value) {
        return !!value && typeof value === 'object';
    }
    function isSpecial(value) {
        if ('$$typeof' in value && '_owner' in value) {
            return true;
        }
        if (value['_isAMomentObject']) {
            return true;
        }
        if (value['_isJSONSchemaObject']) {
            return true;
        }
        if (isFn(value['toJS'])) {
            return true;
        }
        if (isFn(value['toJSON'])) {
            return true;
        }
        return !isPlainObj(value);
    }
    function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
        if (options.clone !== false && options.isMergeableObject(value)) {
            return deepmerge(emptyTarget(value), value, options);
        }
        return value;
    }
    function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function (element) {
            return cloneUnlessOtherwiseSpecified(element, options);
        });
    }
    function getMergeFunction(key, options) {
        if (!options.customMerge) {
            return deepmerge;
        }
        var customMerge = options.customMerge(key);
        return typeof customMerge === 'function' ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols
            ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
                return target.propertyIsEnumerable(symbol);
            })
            : [];
    }
    function getKeys(target) {
        if (!isValid(target))
            return [];
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
        /* istanbul ignore next */
        try {
            return property in object;
        }
        catch (_) {
            return false;
        }
    }
    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
        return (propertyIsOnObject(target, key) && // Properties are safe to merge if they don't exist in the target yet,
            !(Object.hasOwnProperty.call(target, key) && // unsafe if they exist up the prototype chain,
                Object.propertyIsEnumerable.call(target, key))); // and also unsafe if they're nonenumerable.
    }
    function mergeObject(target, source, options) {
        var destination = options.assign ? target || {} : {};
        if (!options.isMergeableObject(target))
            return target;
        if (!options.assign) {
            getKeys(target).forEach(function (key) {
                destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
            });
        }
        getKeys(source).forEach(function (key) {
            /* istanbul ignore next */
            if (propertyIsUnsafe(target, key)) {
                return;
            }
            if (isEmpty(target[key])) {
                destination[key] = source[key];
            }
            else if (propertyIsOnObject(target, key) &&
                options.isMergeableObject(source[key])) {
                destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
            }
            else {
                destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
            }
        });
        return destination;
    }
    function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject =
            options.isMergeableObject || defaultIsMergeableObject;
        // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
        // implementations can use it. The caller may not replace it.
        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
        if (!sourceAndTargetTypesMatch) {
            return cloneUnlessOtherwiseSpecified(source, options);
        }
        else if (sourceIsArray) {
            return options.arrayMerge(target, source, options);
        }
        else {
            return mergeObject(target, source, options);
        }
    }
    var lazyMerge = function (target, source) {
        if (!isValid(source))
            return target;
        if (!isValid(target))
            return source;
        if (typeof target !== 'object')
            return source;
        if (typeof source !== 'object')
            return target;
        return new Proxy({}, {
            get: function (_, key) {
                if (key in source)
                    return source[key];
                return target[key];
            },
            ownKeys: function () {
                var keys = Object.keys(target);
                for (var key in source) {
                    if (!(key in target)) {
                        keys.push(key);
                    }
                }
                return keys;
            },
            getOwnPropertyDescriptor: function () {
                return {
                    enumerable: true,
                    configurable: true,
                    writable: false,
                };
            },
            has: function (_, key) {
                if (key in source || key in target)
                    return true;
                return false;
            },
        });
    };
    var merge = deepmerge;

    var isUnNormalObject = function (value) {
        if ((value === null || value === void 0 ? void 0 : value._owner) && (value === null || value === void 0 ? void 0 : value.$$typeof)) {
            return true;
        }
        if ((value === null || value === void 0 ? void 0 : value._isAMomentObject) || (value === null || value === void 0 ? void 0 : value._isJSONSchemaObject)) {
            return true;
        }
        if ((value === null || value === void 0 ? void 0 : value.toJS) || (value === null || value === void 0 ? void 0 : value.toJSON)) {
            return true;
        }
    };
    var isEnumerableObject = function (val) {
        if (isUnNormalObject(val)) {
            return false;
        }
        return typeof val === 'object';
    };
    /**
     *
     * @param defaults
     * @param targets
     */
    var defaults = function (defaults_, targets) {
        if (getType(defaults_) !== getType(targets) ||
            !isEnumerableObject(defaults_) ||
            !isEnumerableObject(targets)) {
            return !isEmpty(targets) ? targets : defaults_;
        }
        else {
            var results_1 = isArr(defaults_)
                ? []
                : isPlainObj(defaults_)
                    ? {}
                    : defaults_;
            each(targets, function (value, key) {
                results_1[key] = defaults(defaults_[key], value);
            });
            each(defaults_, function (value, key) {
                if (!isValid(results_1[key])) {
                    results_1[key] = value;
                }
            });
            return results_1;
        }
    };

    var IDX = 36, HEX = '';
    while (IDX--)
        HEX += IDX.toString(36);
    function uid(len) {
        var str = '', num = len || 11;
        while (num--)
            str += HEX[(Math.random() * 36) | 0];
        return str;
    }

    var Span = /** @class */ (function () {
        function Span(spanId, trace) {
            if (spanId === void 0) { spanId = undefined; }
            if (trace === void 0) { trace = undefined; }
            this.spanId = spanId;
            this.trace = trace;
            this.trace = trace;
            this.spanId = spanId !== null && spanId !== void 0 ? spanId : uid();
        }
        Span.prototype.begin = function () {
            var _a;
            console.log("[span start]:".concat((_a = this.trace) === null || _a === void 0 ? void 0 : _a.traceId, "->").concat(this.spanId));
            return this;
        };
        Span.prototype.setTrace = function (trace) {
            this.trace = trace;
            this.begin();
            return this;
        };
        Span.prototype.pending = function () {
            this.trace.pending();
        };
        Span.create = function () {
            var span = new Span();
            console.log("[create span]:".concat(span.spanId));
            return span;
        };
        Span.prototype.expectEnd = function () {
            var _a;
            console.log("[span expect end]:".concat((_a = this.trace) === null || _a === void 0 ? void 0 : _a.traceId, "->").concat(this.spanId));
        };
        Span.prototype.toString = function () {
            var _a;
            return "spanId:".concat(this.spanId, ", traceId:").concat((_a = this.trace) === null || _a === void 0 ? void 0 : _a.traceId);
        };
        return Span;
    }());
    var Trace = /** @class */ (function () {
        function Trace(traceId, parent) {
            if (traceId === void 0) { traceId = undefined; }
            if (parent === void 0) { parent = undefined; }
            var _a, _b;
            this.traceId = traceId;
            this.parent = parent;
            this.spans = new Array();
            this.traceId = traceId !== null && traceId !== void 0 ? traceId : uid();
            this.parent = parent;
            this.status = 'Start';
            console.log("[trace start]:".concat(this.traceId, ", parent traceId: ").concat((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.traceId));
        }
        Trace.prototype.attachSpan = function (span) {
            var _span = new Span(span.spanId).setTrace(this);
            this.spans.push(_span);
            return _span;
        };
        Trace.prototype.pending = function () {
            this.status = 'PendingAsync';
        };
        Trace.prototype.expectEnd = function () {
            var _a, _b;
            this.status = this.status === 'PendingAsync' ? 'ExpectFinish' : 'Finsish';
            console.log("[trace expect end]:".concat(this.traceId, ", parent traceId: ").concat((_b = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.trace) === null || _b === void 0 ? void 0 : _b.traceId));
        };
        Trace.prototype.end = function () {
            this.status = 'Finsish';
        };
        return Trace;
    }());
    var ExecutingChainInternal = /** @class */ (function () {
        function ExecutingChainInternal() {
            this.traces = new Map();
        }
        ExecutingChainInternal.prototype.start = function (chain) {
            if (chain === void 0) { chain = {}; }
            var _a = chain || {}, trace = _a.trace, parent = _a.span;
            if (!trace) {
                var _trace = new Trace(undefined, parent);
                this.traces.set(_trace.traceId, trace);
                return _trace;
            }
            return trace;
        };
        return ExecutingChainInternal;
    }());
    var ExecutingChain = new ExecutingChainInternal();
    function wrapChainArgs(chain) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return {
            chain: chain,
            rawArgs: args,
        };
    }
    function unwrapChainArgs(args) {
        var _a;
        if ((_a = args === null || args === void 0 ? void 0 : args[0]) === null || _a === void 0 ? void 0 : _a.chain) {
            return args[0].rawArgs;
        }
        return args;
    }
    function obtainChain(args) {
        var _a;
        if ((_a = args === null || args === void 0 ? void 0 : args[0]) === null || _a === void 0 ? void 0 : _a.chain) {
            return args[0].chain;
        }
        return null;
    }

    exports.ExecutingChain = ExecutingChain;
    exports.FormPath = _global_Formily_Path_Path;
    exports.Span = Span;
    exports.Subscribable = Subscribable;
    exports.Trace = Trace;
    exports.applyMiddleware = applyMiddleware;
    exports.camelCase = camelCase;
    exports.clone = clone;
    exports.defaults = defaults;
    exports.deprecate = deprecate;
    exports.each = each;
    exports.every = every;
    exports.find = find;
    exports.findIndex = findIndex;
    exports.getType = getType;
    exports.globalThisPolyfill = globalThisPolyfill;
    exports.includes = includes;
    exports.instOf = instOf;
    exports.isArr = isArr;
    exports.isBool = isBool;
    exports.isEmpty = isEmpty;
    exports.isEqual = isEqual;
    exports.isFn = isFn;
    exports.isHTMLElement = isHTMLElement;
    exports.isMap = isMap;
    exports.isNum = isNum;
    exports.isNumberLike = isNumberLike;
    exports.isObj = isObj;
    exports.isPlainObj = isPlainObj;
    exports.isReactElement = isReactElement;
    exports.isRegExp = isRegExp;
    exports.isSet = isSet;
    exports.isStr = isStr;
    exports.isUndef = isUndef;
    exports.isValid = isValid;
    exports.isWeakMap = isWeakMap;
    exports.isWeakSet = isWeakSet;
    exports.lazyMerge = lazyMerge;
    exports.lowerCase = lowerCase;
    exports.map = map;
    exports.merge = merge;
    exports.obtainChain = obtainChain;
    exports.paramCase = paramCase;
    exports.pascalCase = pascalCase;
    exports.reduce = reduce;
    exports.shallowClone = shallowClone;
    exports.some = some;
    exports.stringLength = stringLength;
    exports.toArr = toArr;
    exports.uid = uid;
    exports.unwrapChainArgs = unwrapChainArgs;
    exports.upperCase = upperCase;
    exports.wrapChainArgs = wrapChainArgs;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=formily.shared.umd.development.js.map

  </script>
 
  <script id="reactive-script">
    (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('formily.reactive', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.Formily = global.Formily || {}, global.Formily.Reactive = {})));
})(this, (function (exports) { 'use strict';

    (function() {
        const env = {"NODE_ENV":"development"};
        try {
            if (process) {
                process.env = Object.assign({}, process.env);
                Object.assign(process.env, env);
                return;
            }
        } catch (e) {} // avoid ReferenceError: process is not defined
        globalThis.process = { env:env };
    })();

    var toString = Object.prototype.toString;
    var isMap = function (val) {
        return val && val instanceof Map;
    };
    var isSet = function (val) { return val && val instanceof Set; };
    var isWeakMap = function (val) {
        return val && val instanceof WeakMap;
    };
    var isWeakSet = function (val) {
        return val && val instanceof WeakSet;
    };
    var isFn = function (val) { return typeof val === 'function'; };
    var isArr = Array.isArray;
    var isPlainObj = function (val) {
        return toString.call(val) === '[object Object]';
    };
    var isValid = function (val) { return val !== null && val !== undefined; };
    var isCollectionType = function (target) {
        return (isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target));
    };
    var isNormalType = function (target) {
        return isPlainObj(target) || isArr(target);
    };

    var toArray = function (value) {
        return Array.isArray(value)
            ? value
            : value !== undefined && value !== null
                ? [value]
                : [];
    };
    var ArraySet = /** @class */ (function () {
        function ArraySet(value) {
            if (value === void 0) { value = []; }
            this.forEachIndex = 0;
            this.value = value;
        }
        ArraySet.prototype.add = function (item) {
            if (!this.has(item)) {
                this.value.push(item);
            }
        };
        ArraySet.prototype.has = function (item) {
            return this.value.indexOf(item) > -1;
        };
        ArraySet.prototype.delete = function (item) {
            var len = this.value.length;
            if (len === 0)
                return;
            if (len === 1 && this.value[0] === item) {
                this.value = [];
                return;
            }
            var findIndex = this.value.indexOf(item);
            if (findIndex > -1) {
                this.value.splice(findIndex, 1);
                if (findIndex <= this.forEachIndex) {
                    this.forEachIndex -= 1;
                }
            }
        };
        ArraySet.prototype.forEach = function (callback) {
            if (this.value.length === 0)
                return;
            this.forEachIndex = 0;
            for (; this.forEachIndex < this.value.length; this.forEachIndex++) {
                callback(this.value[this.forEachIndex]);
            }
        };
        ArraySet.prototype.batchDelete = function (callback) {
            if (this.value.length === 0)
                return;
            this.forEachIndex = 0;
            for (; this.forEachIndex < this.value.length; this.forEachIndex++) {
                var value = this.value[this.forEachIndex];
                this.value.splice(this.forEachIndex, 1);
                this.forEachIndex--;
                callback(value);
            }
        };
        ArraySet.prototype.clear = function () {
            this.value.length = 0;
        };
        return ArraySet;
    }());

    var ProxyRaw = new WeakMap();
    var RawProxy = new WeakMap();
    var RawShallowProxy = new WeakMap();
    var RawNode = new WeakMap();
    var RawReactionsMap = new WeakMap();
    var ReactionStack = [];
    var BatchCount = { value: 0 };
    var UntrackCount = { value: 0 };
    var BatchScope = { value: false };
    var DependencyCollected = { value: false };
    var PendingReactions = new ArraySet();
    var PendingScopeReactions = new ArraySet();
    var BatchEndpoints = new ArraySet();
    var ObserverListeners = new ArraySet();
    var MakeObModelSymbol = Symbol('MakeObModelSymbol');
    var ObModelSymbol = Symbol('ObModelSymbol');
    var ObModelNodeSymbol = Symbol('ObModelNodeSymbol');

    var ITERATION_KEY = Symbol('iteration key');
    var addRawReactionsMap = function (target, key, reaction) {
        var reactionsMap = RawReactionsMap.get(target);
        if (reactionsMap) {
            var reactions = reactionsMap.get(key);
            if (reactions) {
                reactions.add(reaction);
            }
            else {
                reactionsMap.set(key, new ArraySet([reaction]));
            }
            return reactionsMap;
        }
        else {
            var reactionsMap_1 = new Map([
                [key, new ArraySet([reaction])],
            ]);
            RawReactionsMap.set(target, reactionsMap_1);
            return reactionsMap_1;
        }
    };
    var addReactionsMapToReaction = function (reaction, reactionsMap) {
        var bindSet = reaction._reactionsSet;
        if (bindSet) {
            bindSet.add(reactionsMap);
        }
        else {
            reaction._reactionsSet = new ArraySet([reactionsMap]);
        }
        return bindSet;
    };
    var getReactionsFromTargetKey = function (target, key) {
        var reactionsMap = RawReactionsMap.get(target);
        var reactions = [];
        if (reactionsMap) {
            var map = reactionsMap.get(key);
            if (map) {
                map.forEach(function (reaction) {
                    if (reactions.indexOf(reaction) === -1) {
                        reactions.push(reaction);
                    }
                });
            }
        }
        return reactions;
    };
    var runReactions = function (target, key) {
        var reactions = getReactionsFromTargetKey(target, key);
        var prevUntrackCount = UntrackCount.value;
        UntrackCount.value = 0;
        for (var i = 0, len = reactions.length; i < len; i++) {
            var reaction = reactions[i];
            if (reaction._isComputed) {
                reaction._scheduler(reaction);
            }
            else if (isScopeBatching()) {
                PendingScopeReactions.add(reaction);
            }
            else if (isBatching()) {
                PendingReactions.add(reaction);
                console.log("target is", target);
                console.log("key is ".concat(key.toString()));
                console.log("".concat(reaction._name, " create [span]:[").concat(reaction._span, "]"));
            }
            else {
                if (isFn(reaction._scheduler)) {
                    reaction._scheduler(reaction);
                }
                else {
                    reaction();
                }
            }
        }
        UntrackCount.value = prevUntrackCount;
    };
    var notifyObservers = function (operation) {
        ObserverListeners.forEach(function (fn) { return fn(operation); });
    };
    var bindTargetKeyWithCurrentReaction = function (operation) {
        var key = operation.key, type = operation.type, target = operation.target;
        if (type === 'iterate') {
            key = ITERATION_KEY;
        }
        var reactionLen = ReactionStack.length;
        if (reactionLen === 0)
            return;
        var current = ReactionStack[reactionLen - 1];
        if (isUntracking())
            return;
        if (current) {
            DependencyCollected.value = true;
            addReactionsMapToReaction(current, addRawReactionsMap(target, key, current));
        }
    };
    var bindComputedReactions = function (reaction) {
        if (isFn(reaction)) {
            var current = ReactionStack[ReactionStack.length - 1];
            if (current) {
                var computes = current._computesSet;
                if (computes) {
                    computes.add(reaction);
                }
                else {
                    current._computesSet = new ArraySet([reaction]);
                }
            }
        }
    };
    var runReactionsFromTargetKey = function (operation) {
        var key = operation.key, type = operation.type, target = operation.target, oldTarget = operation.oldTarget;
        batchStart();
        notifyObservers(operation);
        if (type === 'clear') {
            oldTarget.forEach(function (_, key) {
                runReactions(target, key);
            });
        }
        else {
            runReactions(target, key);
        }
        if (type === 'add' || type === 'delete' || type === 'clear') {
            var newKey = Array.isArray(target) ? 'length' : ITERATION_KEY;
            runReactions(target, newKey);
        }
        batchEnd();
    };
    var hasRunningReaction = function () {
        return ReactionStack.length > 0;
    };
    var releaseBindingReactions = function (reaction) {
        var _a;
        (_a = reaction._reactionsSet) === null || _a === void 0 ? void 0 : _a.forEach(function (reactionsMap) {
            reactionsMap.forEach(function (reactions) {
                reactions.delete(reaction);
            });
        });
        PendingReactions.delete(reaction);
        PendingScopeReactions.delete(reaction);
        delete reaction._reactionsSet;
    };
    var suspendComputedReactions = function (current) {
        var _a;
        (_a = current._computesSet) === null || _a === void 0 ? void 0 : _a.forEach(function (reaction) {
            var reactions = getReactionsFromTargetKey(reaction._context, reaction._property);
            if (reactions.length === 0) {
                disposeBindingReactions(reaction);
                reaction._dirty = true;
            }
        });
    };
    var disposeBindingReactions = function (reaction) {
        reaction._disposed = true;
        releaseBindingReactions(reaction);
        suspendComputedReactions(reaction);
    };
    var batchStart = function () {
        BatchCount.value++;
    };
    var batchEnd = function (chain) {
        BatchCount.value--;
        if (BatchCount.value === 0) {
            var prevUntrackCount = UntrackCount.value;
            UntrackCount.value = 0;
            executePendingReactions(chain);
            executeBatchEndpoints();
            UntrackCount.value = prevUntrackCount;
        }
    };
    var batchScopeStart = function () {
        BatchScope.value = true;
    };
    var batchScopeEnd = function () {
        var prevUntrackCount = UntrackCount.value;
        BatchScope.value = false;
        UntrackCount.value = 0;
        PendingScopeReactions.batchDelete(function (reaction) {
            if (isFn(reaction._scheduler)) {
                reaction._scheduler(reaction);
            }
            else {
                reaction();
            }
        });
        UntrackCount.value = prevUntrackCount;
    };
    var untrackStart = function () {
        UntrackCount.value++;
    };
    var untrackEnd = function () {
        UntrackCount.value--;
    };
    var isBatching = function () { return BatchCount.value > 0; };
    var isScopeBatching = function () { return BatchScope.value; };
    var isUntracking = function () { return UntrackCount.value > 0; };
    var executePendingReactions = function (chain) {
        if (PendingReactions.value.length == 0)
            return;
        var traceChain = Formily.Shared.ExecutingChain.start(chain);
        PendingReactions.batchDelete(function (reaction) {
            var span = traceChain.attachSpan(reaction._span);
            if (isFn(reaction._scheduler)) {
                reaction._scheduler(reaction, { span: span });
            }
            else {
                reaction({ span: span });
            }
            span.expectEnd();
        });
        traceChain.expectEnd();
    };
    var executeBatchEndpoints = function () {
        BatchEndpoints.batchDelete(function (callback) {
            callback();
        });
    };
    var hasDepsChange = function (newDeps, oldDeps) {
        if (newDeps === oldDeps)
            return false;
        if (newDeps.length !== oldDeps.length)
            return true;
        if (newDeps.some(function (value, index) { return value !== oldDeps[index]; }))
            return true;
        return false;
    };
    var disposeEffects = function (reaction) {
        if (reaction._effects) {
            try {
                batchStart();
                reaction._effects.queue.forEach(function (item) {
                    if (!item || !item.dispose)
                        return;
                    item.dispose();
                });
            }
            finally {
                batchEnd();
            }
        }
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    var DataChange = /** @class */ (function () {
        function DataChange(operation, node) {
            this.node = node;
            this.key = operation.key;
            this.type = operation.type;
            this.object = operation.target;
            this.value = operation.value;
            this.oldValue = operation.oldValue;
        }
        Object.defineProperty(DataChange.prototype, "path", {
            get: function () {
                return this.node.path.concat(this.key);
            },
            enumerable: false,
            configurable: true
        });
        return DataChange;
    }());
    var DataNode = /** @class */ (function () {
        function DataNode(target, key, value) {
            this.target = target;
            this.key = key;
            this.value = value;
        }
        Object.defineProperty(DataNode.prototype, "path", {
            get: function () {
                if (!this.parent)
                    return this.key ? [this.key] : [];
                return this.parent.path.concat(this.key);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DataNode.prototype, "targetRaw", {
            get: function () {
                return raw(this.target);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DataNode.prototype, "parent", {
            get: function () {
                if (!this.target)
                    return;
                return getDataNode(this.targetRaw);
            },
            enumerable: false,
            configurable: true
        });
        DataNode.prototype.isEqual = function (node) {
            if (this.key) {
                return node.targetRaw === this.targetRaw && node.key === this.key;
            }
            return node.value === this.value;
        };
        DataNode.prototype.contains = function (node) {
            if (node === this)
                return true;
            var parent = node.parent;
            while (!!parent) {
                if (this.isEqual(parent))
                    return true;
                parent = parent.parent;
            }
            return false;
        };
        return DataNode;
    }());
    var getDataNode = function (raw) {
        if (raw === null || raw === void 0 ? void 0 : raw[ObModelNodeSymbol]) {
            return raw[ObModelNodeSymbol];
        }
        return RawNode.get(raw);
    };
    var setDataNode = function (raw, node) {
        if (raw === null || raw === void 0 ? void 0 : raw[ObModelSymbol]) {
            raw[ObModelNodeSymbol] = node;
            return;
        }
        RawNode.set(raw, node);
    };
    var buildDataTree = function (target, key, value) {
        var raw$1 = raw(value);
        var currentNode = getDataNode(raw$1);
        if (currentNode)
            return currentNode;
        setDataNode(raw$1, new DataNode(target, key, value));
    };

    var RAW_TYPE = Symbol('RAW_TYPE');
    var OBSERVABLE_TYPE = Symbol('OBSERVABLE_TYPE');
    var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    var isObservable = function (target) {
        return ProxyRaw.has(target) || !!(target === null || target === void 0 ? void 0 : target[ObModelSymbol]);
    };
    var isAnnotation = function (target) {
        return target && !!target[MakeObModelSymbol];
    };
    var isSupportObservable = function (target) {
        if (!isValid(target))
            return false;
        if (isArr(target))
            return true;
        if (isPlainObj(target)) {
            if (target[RAW_TYPE]) {
                return false;
            }
            if (target[OBSERVABLE_TYPE]) {
                return true;
            }
            if ('$$typeof' in target && '_owner' in target) {
                return false;
            }
            if (target['_isAMomentObject']) {
                return false;
            }
            if (target['_isJSONSchemaObject']) {
                return false;
            }
            if (isFn(target['toJS'])) {
                return false;
            }
            if (isFn(target['toJSON'])) {
                return false;
            }
            return true;
        }
        if (isMap(target) || isWeakMap(target) || isSet(target) || isWeakSet(target))
            return true;
        return false;
    };
    var markRaw = function (target) {
        if (!target)
            return;
        if (isFn(target)) {
            target.prototype[RAW_TYPE] = true;
        }
        else {
            target[RAW_TYPE] = true;
        }
        return target;
    };
    var markObservable = function (target) {
        if (!target)
            return;
        if (isFn(target)) {
            target.prototype[OBSERVABLE_TYPE] = true;
        }
        else {
            target[OBSERVABLE_TYPE] = true;
        }
        return target;
    };
    var raw = function (target) {
        if (target === null || target === void 0 ? void 0 : target[ObModelSymbol])
            return target[ObModelSymbol];
        return ProxyRaw.get(target) || target;
    };
    var toJS = function (values) {
        var visited = new WeakSet();
        var _toJS = function (values) {
            if (visited.has(values)) {
                return values;
            }
            if (values && values[RAW_TYPE])
                return values;
            if (isArr(values)) {
                if (isObservable(values)) {
                    visited.add(values);
                    var res_1 = [];
                    values.forEach(function (item) {
                        res_1.push(_toJS(item));
                    });
                    visited.delete(values);
                    return res_1;
                }
            }
            else if (isPlainObj(values)) {
                if (isObservable(values)) {
                    visited.add(values);
                    var res = {};
                    for (var key in values) {
                        if (hasOwnProperty$1.call(values, key)) {
                            res[key] = _toJS(values[key]);
                        }
                    }
                    visited.delete(values);
                    return res;
                }
            }
            return values;
        };
        return _toJS(values);
    };
    var contains = function (target, property) {
        var targetRaw = raw(target);
        var propertyRaw = raw(property);
        if (targetRaw === propertyRaw)
            return true;
        var targetNode = getDataNode(targetRaw);
        var propertyNode = getDataNode(propertyRaw);
        if (!targetNode)
            return false;
        if (!propertyNode)
            return false;
        return targetNode.contains(propertyNode);
    };
    var hasCollected = function (callback) {
        DependencyCollected.value = false;
        callback === null || callback === void 0 ? void 0 : callback();
        return DependencyCollected.value;
    };

    var _a;
    var wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol)
        .map(function (key) { return Symbol[key]; })
        .filter(function (value) { return typeof value === 'symbol'; }));
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function findObservable(target, key, value) {
        var observableObj = RawProxy.get(value);
        if (observableObj) {
            return observableObj;
        }
        if (!isObservable(value) && isSupportObservable(value)) {
            return createObservable(target, key, value);
        }
        return value;
    }
    function patchIterator(target, key, iterator, isEntries) {
        var originalNext = iterator.next;
        iterator.next = function () {
            var _a = originalNext.call(iterator), done = _a.done, value = _a.value;
            if (!done) {
                if (isEntries) {
                    value[1] = findObservable(target, key, value[1]);
                }
                else {
                    value = findObservable(target, key, value);
                }
            }
            return { done: done, value: value };
        };
        return iterator;
    }
    var instrumentations = (_a = {
            has: function (key) {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'has' });
                return proto.has.apply(target, arguments);
            },
            get: function (key) {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'get' });
                return findObservable(target, key, proto.get.apply(target, arguments));
            },
            add: function (key) {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                var hadKey = proto.has.call(target, key);
                // forward the operation before queueing reactions
                var result = proto.add.apply(target, arguments);
                if (!hadKey) {
                    runReactionsFromTargetKey({ target: target, key: key, value: key, type: 'add' });
                }
                return result;
            },
            set: function (key, value) {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                var hadKey = proto.has.call(target, key);
                var oldValue = proto.get.call(target, key);
                // forward the operation before queueing reactions
                var result = proto.set.apply(target, arguments);
                if (!hadKey) {
                    runReactionsFromTargetKey({ target: target, key: key, value: value, type: 'add' });
                }
                else if (value !== oldValue) {
                    runReactionsFromTargetKey({ target: target, key: key, value: value, oldValue: oldValue, type: 'set' });
                }
                return result;
            },
            delete: function (key) {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                var hadKey = proto.has.call(target, key);
                var oldValue = proto.get ? proto.get.call(target, key) : undefined;
                // forward the operation before queueing reactions
                var result = proto.delete.apply(target, arguments);
                if (hadKey) {
                    runReactionsFromTargetKey({ target: target, key: key, oldValue: oldValue, type: 'delete' });
                }
                return result;
            },
            clear: function () {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                var hadItems = target.size !== 0;
                var oldTarget = target instanceof Map ? new Map(target) : new Set(target);
                // forward the operation before queueing reactions
                var result = proto.clear.apply(target, arguments);
                if (hadItems) {
                    runReactionsFromTargetKey({ target: target, oldTarget: oldTarget, type: 'clear' });
                }
                return result;
            },
            forEach: function (cb) {
                var _a;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
                // swap out the raw values with their observable pairs
                // before passing them to the callback
                var wrappedCb = function (value, key) {
                    var args = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        args[_i - 2] = arguments[_i];
                    }
                    return cb.apply(void 0, __spreadArray([findObservable(target, key, value), key], __read(args)));
                };
                return (_a = proto.forEach).call.apply(_a, __spreadArray([target, wrappedCb], __read(args)));
            },
            keys: function () {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
                return proto.keys.apply(target, arguments);
            },
            values: function () {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
                var iterator = proto.values.apply(target, arguments);
                return patchIterator(target, '', iterator, false);
            },
            entries: function () {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
                var iterator = proto.entries.apply(target, arguments);
                return patchIterator(target, '', iterator, true);
            }
        },
        _a[Symbol.iterator] = function () {
            var target = ProxyRaw.get(this);
            var proto = Reflect.getPrototypeOf(this);
            bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            var iterator = proto[Symbol.iterator].apply(target, arguments);
            return patchIterator(target, '', iterator, target instanceof Map);
        },
        Object.defineProperty(_a, "size", {
            get: function () {
                var target = ProxyRaw.get(this);
                var proto = Reflect.getPrototypeOf(this);
                bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
                return Reflect.get(proto, 'size', target);
            },
            enumerable: false,
            configurable: true
        }),
        _a);
    var collectionHandlers = {
        get: function (target, key, receiver) {
            // instrument methods and property accessors to be reactive
            target = hasOwnProperty.call(instrumentations, key)
                ? instrumentations
                : target;
            return Reflect.get(target, key, receiver);
        },
    };
    var baseHandlers = {
        get: function (target, key, receiver) {
            if (!key)
                return;
            var result = target[key]; // use Reflect.get is too slow
            if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {
                return result;
            }
            bindTargetKeyWithCurrentReaction({ target: target, key: key, receiver: receiver, type: 'get' });
            var observableResult = RawProxy.get(result);
            if (observableResult) {
                return observableResult;
            }
            if (!isObservable(result) && isSupportObservable(result)) {
                var descriptor = Reflect.getOwnPropertyDescriptor(target, key);
                if (!descriptor ||
                    !(descriptor.writable === false && descriptor.configurable === false)) {
                    return createObservable(target, key, result);
                }
            }
            return result;
        },
        has: function (target, key) {
            var result = Reflect.has(target, key);
            bindTargetKeyWithCurrentReaction({ target: target, key: key, type: 'has' });
            return result;
        },
        ownKeys: function (target) {
            var keys = Reflect.ownKeys(target);
            bindTargetKeyWithCurrentReaction({ target: target, type: 'iterate' });
            return keys;
        },
        set: function (target, key, value, receiver) {
            var hadKey = hasOwnProperty.call(target, key);
            var newValue = createObservable(target, key, value);
            var oldValue = target[key];
            target[key] = newValue; // use Reflect.set is too slow
            if (!hadKey) {
                runReactionsFromTargetKey({
                    target: target,
                    key: key,
                    value: newValue,
                    oldValue: oldValue,
                    receiver: receiver,
                    type: 'add',
                });
            }
            else if (value !== oldValue) {
                runReactionsFromTargetKey({
                    target: target,
                    key: key,
                    value: newValue,
                    oldValue: oldValue,
                    receiver: receiver,
                    type: 'set',
                });
            }
            return true;
        },
        deleteProperty: function (target, key) {
            var oldValue = target[key];
            delete target[key];
            runReactionsFromTargetKey({
                target: target,
                key: key,
                oldValue: oldValue,
                type: 'delete',
            });
            return true;
        },
    };

    var createNormalProxy = function (target, shallow) {
        var proxy = new Proxy(target, baseHandlers);
        ProxyRaw.set(proxy, target);
        if (shallow) {
            RawShallowProxy.set(target, proxy);
        }
        else {
            RawProxy.set(target, proxy);
        }
        return proxy;
    };
    var createCollectionProxy = function (target, shallow) {
        var proxy = new Proxy(target, collectionHandlers);
        ProxyRaw.set(proxy, target);
        if (shallow) {
            RawShallowProxy.set(target, proxy);
        }
        else {
            RawProxy.set(target, proxy);
        }
        return proxy;
    };
    var createShallowProxy = function (target) {
        if (isNormalType(target))
            return createNormalProxy(target, true);
        if (isCollectionType(target))
            return createCollectionProxy(target, true);
        return target;
    };
    var createObservable = function (target, key, value, shallow) {
        if (typeof value !== 'object')
            return value;
        var raw = ProxyRaw.get(value);
        if (!!raw) {
            var node = getDataNode(raw);
            if (!node.target)
                node.target = target;
            node.key = key;
            return value;
        }
        if (!isSupportObservable(value))
            return value;
        if (target) {
            var parentRaw = ProxyRaw.get(target) || target;
            var isShallowParent = RawShallowProxy.get(parentRaw);
            if (isShallowParent)
                return value;
        }
        buildDataTree(target, key, value);
        if (shallow)
            return createShallowProxy(value);
        if (isNormalType(value))
            return createNormalProxy(value);
        if (isCollectionType(value))
            return createCollectionProxy(value);
        return value;
    };
    var createAnnotation = function (maker) {
        var annotation = function (target) {
            return maker({ value: target });
        };
        if (isFn(maker)) {
            annotation[MakeObModelSymbol] = maker;
        }
        return annotation;
    };
    var getObservableMaker = function (target) {
        if (target[MakeObModelSymbol]) {
            if (!target[MakeObModelSymbol][MakeObModelSymbol]) {
                return target[MakeObModelSymbol];
            }
            return getObservableMaker(target[MakeObModelSymbol]);
        }
    };
    var createBoundaryFunction = function (start, end) {
        function boundary(fn, chain) {
            var results;
            try {
                start();
                if (isFn(fn)) {
                    results = fn();
                }
            }
            finally {
                end(chain);
            }
            return results;
        }
        boundary.bound = createBindFunction(boundary);
        return boundary;
    };
    var createBindFunction = function (boundary) {
        function bind(callback, context) {
            return (function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return boundary(function () { return callback.apply(context, Formily.Shared.unwrapChainArgs(args)); }, Formily.Shared.obtainChain(args));
            });
        }
        return bind;
    };
    var createBoundaryAnnotation = function (start, end) {
        var boundary = createBoundaryFunction(start, end);
        var annotation = createAnnotation(function (_a) {
            var target = _a.target, key = _a.key;
            target[key] = boundary.bound(target[key], target);
            return target;
        });
        boundary[MakeObModelSymbol] = annotation;
        boundary.bound[MakeObModelSymbol] = annotation;
        return boundary;
    };

    var batch = createBoundaryAnnotation(batchStart, batchEnd);
    batch.scope = createBoundaryAnnotation(batchScopeStart, batchScopeEnd);
    batch.endpoint = function (callback) {
        if (!isFn(callback))
            return;
        if (BatchCount.value === 0) {
            callback();
        }
        else {
            BatchEndpoints.add(callback);
        }
    };

    var action = createBoundaryAnnotation(function () {
        batchStart();
        untrackStart();
    }, function (chain) {
        untrackEnd();
        batchEnd(chain);
    });
    action.scope = createBoundaryAnnotation(function () {
        batchScopeStart();
        untrackStart();
    }, function () {
        untrackEnd();
        batchScopeEnd();
    });

    var untracked = createBoundaryFunction(untrackStart, untrackEnd);

    var observable$1 = createAnnotation(function (_a) {
        var target = _a.target, key = _a.key, value = _a.value;
        var store = {
            value: createObservable(target, key, target ? target[key] : value),
        };
        function get() {
            bindTargetKeyWithCurrentReaction({
                target: target,
                key: key,
                type: 'get',
            });
            return store.value;
        }
        function set(value) {
            var oldValue = store.value;
            value = createObservable(target, key, value);
            store.value = value;
            if (oldValue === value)
                return;
            runReactionsFromTargetKey({
                target: target,
                key: key,
                type: 'set',
                oldValue: oldValue,
                value: value,
            });
        }
        if (target) {
            Object.defineProperty(target, key, {
                set: set,
                get: get,
                enumerable: true,
                configurable: false,
            });
            return target;
        }
        return store.value;
    });

    var box = createAnnotation(function (_a) {
        var target = _a.target, key = _a.key, value = _a.value;
        var store = {
            value: target ? target[key] : value,
        };
        var proxy = {
            set: set,
            get: get,
        };
        ProxyRaw.set(proxy, store);
        RawProxy.set(store, proxy);
        buildDataTree(target, key, store);
        function get() {
            bindTargetKeyWithCurrentReaction({
                target: store,
                key: key,
                type: 'get',
            });
            return store.value;
        }
        function set(value) {
            var oldValue = store.value;
            store.value = value;
            if (oldValue !== value) {
                runReactionsFromTargetKey({
                    target: store,
                    key: key,
                    type: 'set',
                    oldValue: oldValue,
                    value: value,
                });
            }
        }
        if (target) {
            Object.defineProperty(target, key, {
                value: proxy,
                enumerable: true,
                configurable: false,
                writable: false,
            });
            return target;
        }
        return proxy;
    });

    var ref = createAnnotation(function (_a) {
        var target = _a.target, key = _a.key, value = _a.value;
        var store = {
            value: target ? target[key] : value,
        };
        var proxy = {};
        var context = target ? target : store;
        var property = target ? key : 'value';
        function get() {
            bindTargetKeyWithCurrentReaction({
                target: context,
                key: property,
                type: 'get',
            });
            return store.value;
        }
        function set(value) {
            var oldValue = store.value;
            store.value = value;
            if (oldValue !== value) {
                runReactionsFromTargetKey({
                    target: context,
                    key: property,
                    type: 'set',
                    oldValue: oldValue,
                    value: value,
                });
            }
        }
        if (target) {
            Object.defineProperty(target, key, {
                get: get,
                set: set,
                enumerable: true,
            });
            return target;
        }
        else {
            Object.defineProperty(proxy, 'value', {
                set: set,
                get: get,
            });
            buildDataTree(target, key, store);
            proxy[ObModelSymbol] = store;
        }
        return proxy;
    });

    var shallow = createAnnotation(function (_a) {
        var target = _a.target, key = _a.key, value = _a.value;
        var store = {
            value: createObservable(target, key, target ? target[key] : value, true),
        };
        function get() {
            bindTargetKeyWithCurrentReaction({
                target: target,
                key: key,
                type: 'get',
            });
            return store.value;
        }
        function set(value) {
            var oldValue = store.value;
            value = createObservable(target, key, value, true);
            store.value = value;
            if (oldValue === value)
                return;
            runReactionsFromTargetKey({
                target: target,
                key: key,
                type: 'set',
                oldValue: oldValue,
                value: value,
            });
        }
        if (target) {
            Object.defineProperty(target, key, {
                set: set,
                get: get,
                enumerable: true,
                configurable: false,
            });
            return target;
        }
        return store.value;
    });

    var getDescriptor = Object.getOwnPropertyDescriptor;
    var getProto = Object.getPrototypeOf;
    var ClassDescriptorSymbol = Symbol('ClassDescriptorSymbol');
    function getPropertyDescriptor(obj, key) {
        if (!obj)
            return;
        return getDescriptor(obj, key) || getPropertyDescriptor(getProto(obj), key);
    }
    function getPropertyDescriptorCache(obj, key) {
        var constructor = obj.constructor;
        if (constructor === Object || constructor === Array)
            return getPropertyDescriptor(obj, key);
        var cache = constructor[ClassDescriptorSymbol] || {};
        var descriptor = cache[key];
        if (descriptor)
            return descriptor;
        var newDesc = getPropertyDescriptor(obj, key);
        constructor[ClassDescriptorSymbol] = cache;
        cache[key] = newDesc;
        return newDesc;
    }
    function getPrototypeDescriptor(target, key, value) {
        if (!target) {
            if (value) {
                if (isFn(value)) {
                    return { get: value };
                }
                else {
                    return value;
                }
            }
            return {};
        }
        var descriptor = getPropertyDescriptorCache(target, key);
        if (descriptor) {
            return descriptor;
        }
        return {};
    }
    var computed = createAnnotation(function (_a) {
        var target = _a.target, key = _a.key, value = _a.value;
        var store = {};
        var proxy = {};
        var context = target ? target : store;
        var property = target ? key : 'value';
        var descriptor = getPrototypeDescriptor(target, property, value);
        function compute() {
            var _a;
            store.value = (_a = descriptor.get) === null || _a === void 0 ? void 0 : _a.call(context);
        }
        function reaction() {
            if (ReactionStack.indexOf(reaction) === -1) {
                releaseBindingReactions(reaction);
                try {
                    ReactionStack.push(reaction);
                    compute();
                }
                finally {
                    ReactionStack.pop();
                }
            }
        }
        reaction._name = 'ComputedReaction';
        reaction._scheduler = function () {
            reaction._dirty = true;
            runReactionsFromTargetKey({
                target: context,
                key: property,
                value: store.value,
                type: 'set',
            });
        };
        reaction._isComputed = true;
        reaction._dirty = true;
        reaction._context = context;
        reaction._property = property;
        reaction._span = Formily.Shared.Span.create();
        function get() {
            if (hasRunningReaction()) {
                bindComputedReactions(reaction);
            }
            if (!isUntracking()) {
                //untracked_dirtyfalse
                if (reaction._dirty) {
                    reaction();
                    reaction._dirty = false;
                }
            }
            else {
                compute();
            }
            bindTargetKeyWithCurrentReaction({
                target: context,
                key: property,
                type: 'get',
            });
            return store.value;
        }
        function set(value) {
            var _a;
            try {
                batchStart();
                (_a = descriptor.set) === null || _a === void 0 ? void 0 : _a.call(context, value);
            }
            finally {
                batchEnd();
            }
        }
        if (target) {
            Object.defineProperty(target, key, {
                get: get,
                set: set,
                enumerable: true,
            });
            return target;
        }
        else {
            Object.defineProperty(proxy, 'value', {
                set: set,
                get: get,
            });
            buildDataTree(target, key, store);
            proxy[ObModelSymbol] = store;
        }
        return proxy;
    });

    function observable(target) {
        return createObservable(null, null, target);
    }
    observable.box = box;
    observable.ref = ref;
    observable.deep = observable$1;
    observable.shallow = shallow;
    observable.computed = computed;
    observable[MakeObModelSymbol] = observable$1;

    function define(target, annotations) {
        if (isObservable(target))
            return target;
        if (!isSupportObservable(target))
            return target;
        target[ObModelSymbol] = target;
        buildDataTree(undefined, undefined, target);
        for (var key in annotations) {
            var annotation = annotations[key];
            if (isAnnotation(annotation)) {
                getObservableMaker(annotation)({
                    target: target,
                    key: key,
                });
            }
        }
        return target;
    }
    function model(target) {
        var annotations = Object.keys(target || {}).reduce(function (buf, key) {
            var descriptor = Object.getOwnPropertyDescriptor(target, key);
            if (descriptor && descriptor.get) {
                buf[key] = observable.computed;
            }
            else if (isFn(target[key])) {
                buf[key] = action;
            }
            else {
                buf[key] = observable;
            }
            return buf;
        }, {});
        return define(target, annotations);
    }

    var autorun = function (tracker, name) {
        if (name === void 0) { name = 'AutoRun'; }
        var reaction = function (chain) {
            if (!isFn(tracker))
                return;
            if (reaction._boundary > 0)
                return;
            if (ReactionStack.indexOf(reaction) === -1) {
                releaseBindingReactions(reaction);
                try {
                    batchStart();
                    ReactionStack.push(reaction);
                    tracker(chain);
                }
                finally {
                    ReactionStack.pop();
                    reaction._boundary++;
                    batchEnd();
                    reaction._boundary = 0;
                    reaction._memos.cursor = 0;
                    reaction._effects.cursor = 0;
                }
            }
        };
        var cleanRefs = function () {
            reaction._memos = {
                queue: [],
                cursor: 0,
            };
            reaction._effects = {
                queue: [],
                cursor: 0,
            };
        };
        reaction._boundary = 0;
        reaction._name = name;
        reaction._span = Formily.Shared.Span.create();
        cleanRefs();
        reaction();
        return function () {
            disposeBindingReactions(reaction);
            disposeEffects(reaction);
            cleanRefs();
        };
    };
    autorun.memo = function (callback, dependencies) {
        if (!isFn(callback))
            return;
        var current = ReactionStack[ReactionStack.length - 1];
        if (!current || !current._memos)
            throw new Error('autorun.memo must used in autorun function body.');
        var deps = toArray(dependencies || []);
        var id = current._memos.cursor++;
        var old = current._memos.queue[id];
        if (!old || hasDepsChange(deps, old.deps)) {
            var value = callback();
            current._memos.queue[id] = {
                value: value,
                deps: deps,
            };
            return value;
        }
        return old.value;
    };
    autorun.effect = function (callback, dependencies) {
        if (!isFn(callback))
            return;
        var current = ReactionStack[ReactionStack.length - 1];
        if (!current || !current._effects)
            throw new Error('autorun.effect must used in autorun function body.');
        var effects = current._effects;
        var deps = toArray(dependencies || [{}]);
        var id = effects.cursor++;
        var old = effects.queue[id];
        if (!old || hasDepsChange(deps, old.deps)) {
            Promise.resolve(0).then(function () {
                if (current._disposed)
                    return;
                var dispose = callback();
                if (isFn(dispose)) {
                    effects.queue[id].dispose = dispose;
                }
            });
            effects.queue[id] = {
                deps: deps,
            };
        }
    };
    var reaction = function (tracker, subscriber, options) {
        var realOptions = __assign({ name: 'Reaction' }, options);
        var value = {};
        var dirtyCheck = function () {
            if (isFn(realOptions.equals))
                return !realOptions.equals(value.oldValue, value.currentValue);
            return value.oldValue !== value.currentValue;
        };
        var fireAction = function (chain) {
            try {
                //untrackschedulersetStateReact
                batchStart();
                if (isFn(subscriber))
                    subscriber(value.currentValue, value.oldValue, chain);
            }
            finally {
                batchEnd(chain);
            }
        };
        var reaction = function () {
            if (ReactionStack.indexOf(reaction) === -1) {
                releaseBindingReactions(reaction);
                try {
                    ReactionStack.push(reaction);
                    value.currentValue = tracker();
                }
                finally {
                    ReactionStack.pop();
                }
            }
        };
        reaction._scheduler = function (looping, chain) {
            looping();
            if (dirtyCheck())
                fireAction(chain);
            value.oldValue = value.currentValue;
        };
        reaction._name = realOptions.name;
        reaction._span = Formily.Shared.Span.create();
        reaction();
        value.oldValue = value.currentValue;
        if (realOptions.fireImmediately) {
            fireAction();
        }
        return function () {
            disposeBindingReactions(reaction);
        };
    };

    var Tracker = /** @class */ (function () {
        function Tracker(scheduler, name) {
            if (name === void 0) { name = 'TrackerReaction'; }
            var _this = this;
            this.track = function (tracker) {
                if (!isFn(tracker))
                    return _this.results;
                if (_this.track._boundary > 0)
                    return;
                if (ReactionStack.indexOf(_this.track) === -1) {
                    releaseBindingReactions(_this.track);
                    try {
                        batchStart();
                        ReactionStack.push(_this.track);
                        _this.results = tracker();
                    }
                    finally {
                        ReactionStack.pop();
                        _this.track._boundary++;
                        batchEnd();
                        _this.track._boundary = 0;
                    }
                }
                return _this.results;
            };
            this.dispose = function () {
                disposeBindingReactions(_this.track);
            };
            this.track._scheduler = function (callback) {
                if (_this.track._boundary === 0)
                    _this.dispose();
                if (isFn(callback))
                    scheduler(callback);
            };
            this.track._name = name;
            this.track._boundary = 0;
            // trackerchain
            this.track._span = Formily.Shared.Span.create();
        }
        return Tracker;
    }());

    var observe = function (target, observer, deep) {
        if (deep === void 0) { deep = true; }
        var addListener = function (target) {
            var raw$1 = raw(target);
            var node = getDataNode(raw$1);
            var listener = function (operation) {
                var targetRaw = raw(operation.target);
                var targetNode = getDataNode(targetRaw);
                if (deep) {
                    if (node.contains(targetNode)) {
                        observer(new DataChange(operation, targetNode));
                        return;
                    }
                }
                if (node === targetNode ||
                    (node.targetRaw === targetRaw && node.key === operation.key)) {
                    observer(new DataChange(operation, targetNode));
                }
            };
            if (node && isFn(observer)) {
                ObserverListeners.add(listener);
            }
            return function () {
                ObserverListeners.delete(listener);
            };
        };
        if (target && typeof target !== 'object')
            throw Error("Can not observe ".concat(typeof target, " type."));
        return addListener(target);
    };

    exports.BatchCount = BatchCount;
    exports.BatchEndpoints = BatchEndpoints;
    exports.BatchScope = BatchScope;
    exports.DataChange = DataChange;
    exports.DataNode = DataNode;
    exports.DependencyCollected = DependencyCollected;
    exports.MakeObModelSymbol = MakeObModelSymbol;
    exports.ObModelNodeSymbol = ObModelNodeSymbol;
    exports.ObModelSymbol = ObModelSymbol;
    exports.ObserverListeners = ObserverListeners;
    exports.PendingReactions = PendingReactions;
    exports.PendingScopeReactions = PendingScopeReactions;
    exports.ProxyRaw = ProxyRaw;
    exports.RawNode = RawNode;
    exports.RawProxy = RawProxy;
    exports.RawReactionsMap = RawReactionsMap;
    exports.RawShallowProxy = RawShallowProxy;
    exports.ReactionStack = ReactionStack;
    exports.Tracker = Tracker;
    exports.UntrackCount = UntrackCount;
    exports.action = action;
    exports.autorun = autorun;
    exports.batch = batch;
    exports.buildDataTree = buildDataTree;
    exports.contains = contains;
    exports.define = define;
    exports.getDataNode = getDataNode;
    exports.hasCollected = hasCollected;
    exports.isAnnotation = isAnnotation;
    exports.isObservable = isObservable;
    exports.isSupportObservable = isSupportObservable;
    exports.markObservable = markObservable;
    exports.markRaw = markRaw;
    exports.model = model;
    exports.observable = observable;
    exports.observe = observe;
    exports.raw = raw;
    exports.reaction = reaction;
    exports.setDataNode = setDataNode;
    exports.toJS = toJS;
    exports.untracked = untracked;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=formily.reactive.umd.development.js.map

  </script>
 
 <script src="https://unpkg.com/dayjs@1.11.7/dayjs.min.js"></script>
 <script src="https://unpkg.com/moment/min/moment-with-locales.js"></script>
 <script src="https://unpkg.com/react/umd/react.production.min.js"></script>
 <script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js"></script>
 <script src="https://unpkg.com/antd@5.1.4/dist/antd-with-locales.min.js"></script>
</body>